<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis初探</title>
      <link href="/2020/02/01/redis-chu-tan/"/>
      <url>/2020/02/01/redis-chu-tan/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常见排序算法总结</title>
      <link href="/2020/01/30/chang-jian-pai-xu-suan-fa-zong-jie/"/>
      <url>/2020/01/30/chang-jian-pai-xu-suan-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年总结</title>
      <link href="/2020/01/19/2019-nian-zong-jie/"/>
      <url>/2020/01/19/2019-nian-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>2019年过去了，虽然现在已经是2020年一月下旬了，但是我不太喜欢去用阳历的时间划分时间节点，即使自己生日都是过的阴历生日，可能自己性格属于那种比较偏老成一些吧。去年大年三十晚上是我第一次写自己的年终总结，我可能真是个神人，大年三十晚上写完总结才去吃的年夜饭，可能自己有一些强迫症吧。回顾自己这一年的点点滴滴，感觉比之前更加务实了很多，之前大一大二那会做过很多傻事，所以感觉2019年变得稍微稳重了一些，如果给自己2019年的工作打个分的话就是80分吧（满分100），我的2019年简而言之可以用以下的关键词总结：<strong>三次比赛</strong>、<strong>一场马拉松</strong>、<strong>一次实习</strong>、<strong>一场恋爱</strong>、<strong>两次旅行</strong>、<strong>一场演唱会</strong>。</p><h2 id="比赛"><a href="#比赛" class="headerlink" title="比赛"></a>比赛</h2><h3 id="微信小程序开发大赛"><a href="#微信小程序开发大赛" class="headerlink" title="微信小程序开发大赛"></a>微信小程序开发大赛</h3><p>之前一直没有参加过什么比赛，所以我在今年就想着能多去参加一些比赛锻炼一下自己的能力，因为之前给别人做过微信小程序的缘故所以就想着参加一下，或许会比较有把握，然而最后的结果并不那么好，看来还得更加努力了。</p><p><img src="https://i.loli.net/2020/01/19/kYRsdEw7ZxKf3mu.png" alt="当时在西北大学听腾讯产品经理开的的宣讲会"></p><p><img src="https://i.loli.net/2020/01/19/x7mdvEcygO1rlTL.png" alt="和学弟在创咖敲代码"></p><p>其实当时四月份的时候就开始留意比赛的信息了，但是一直到五月份才正式开始做，我觉得最后没能得奖我自己有很多失误的地方</p><ol><li><p>开始做的太晚导致时间不够</p></li><li><p>团队成员都是新手，再加上能力都一般，所以效率很低</p></li><li><p>小程序的主题不是那么明确，实用性不高</p></li></ol><p>不过不管怎么样都算是积累了一次宝贵的经验吧，寒假这几天在家把之前的项目整理了一下放在了github上边，后边想看的时候也可以再看看。</p><h3 id="全国大学生数学建模竞赛"><a href="#全国大学生数学建模竞赛" class="headerlink" title="全国大学生数学建模竞赛"></a>全国大学生数学建模竞赛</h3><p>数学建模之前大一那会参加过一次校赛，但是无奈找的队友实在坑人就不提了。这次参加的是九月份的国赛，按照我们学校的惯例是参加国赛的都需要进行暑期培训，不过因为我之前并没有打算参加数学建模竞赛，是之前的一个同学他们一个队友因为中秋节要回家才临时找的我，所以我就完美的躲过了培训~hahaha(本来我暑假那会也在实习，没有时间)。</p><p><img src="https://i.loli.net/2020/01/19/FIzELeaB84g5iCD.png" alt="沉思中"></p><p>我当时负责的是编程实现模型，事实上并不仅仅是编程，因为当时做的题目需要大量航班数据，所以我又自己写了一个爬虫程序爬了几千个航班数据，说实话，那几天的工作强度真心顶不住<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span>，不过最后很欣慰的是拿了陕西省二等奖<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>。</p><h3 id="共享杯比赛"><a href="#共享杯比赛" class="headerlink" title="共享杯比赛"></a>共享杯比赛</h3><p>当时忙完数学建模竞赛后便基本没啥事了，所以想着再参加一些比赛，下学期考研应该也就没时间参加比赛了，刚好无意中在网上看到<a href="http://share.escience.net.cn/nav/newIndex" target="_blank" rel="noopener"><strong>“共享杯”大学生科技资源共享服务创新大赛</strong></a>就想着参加参加看，当时做的是一个双人在线灾害知识竞赛的桌面软件，类似于单词PK那种形式，比较创新的地方可能就是使用了Electron和websocket技术，页面没有用传统的类似于QT那种图形库做，而是找了一个做前端的同学直接用前端网页的形式做的，最后直接部署在Electron这个桌面框架里边，另外websocket也是我第一次用，平时的客户机与服务器的网络通信大都是一次性的，发送完成后下次发送需要重新连接，但是websocket则是类似于打电话一样实时交互，下边放几张应用运行的截图吧。</p><p><img src="https://i.loli.net/2020/01/19/FqnXs1KHbmSOto6.png" alt="应用主页"></p><p><img src="https://i.loli.net/2020/01/19/mPUVyKuTdrSNG5q.png" alt="答题页面"></p><h2 id="大学城马拉松"><a href="#大学城马拉松" class="headerlink" title="大学城马拉松"></a>大学城马拉松</h2><p>有史以来第一次参加马拉松，虽然是青春跑（只有6.5公里），但是跑完真的太累了，还好当时没放弃，总之非常nice，以后有机会还会再参加的。</p><p><img src="https://i.loli.net/2020/01/19/C4jfgOtLMmxe2JA.png" alt="鸣枪开跑"></p><p><img src="https://i.loli.net/2020/01/19/drsXHayYFu1t9bw.png" alt="奖牌(我记得自己当时好像跑了七十多名😁)"></p><h2 id="暑假实习"><a href="#暑假实习" class="headerlink" title="暑假实习"></a>暑假实习</h2><p>因为本科在的实验室一直和西安中霖科技公司这边有合作项目，再加上我们一般暑假假期只有四十天左右，也没时间去面试别的公司，因为大都要求实习三个月起步，所以当时给老师说了一下就直接去公司实习了，公司不是很大，大概只有五十个人左右，一直做的是政府的项目，所以搬到陕西省科技厅里边办公，不过我当时住学校，每天早上坐公交去上班就得一个多小时，所以经常都是踩点到。当时做的模块是类似于pdf预览的功能，不过pdf里边的内容每次都不一样，都是动态生成的数据，当时确实感觉自己挺菜的，还好感谢各位同事们的关照，真的收获很多。</p><p><img src="https://i.loli.net/2020/01/19/UKiAhqjCt8lyWmN.png" alt="就在科技厅的楼里边上班"></p><h2 id="情感状况"><a href="#情感状况" class="headerlink" title="情感状况"></a>情感状况</h2><p>大二第二学期遇到了第二个女朋友，是个东北女孩，两个人认识不久就在一起了，但是没多久就分手了，感觉挺对不住她的，可能当时两个人互相了解的还是太少，我当时可能更多的只是想找一个人能够互相陪伴，在一起后发现两个人性格差距挺大的，随人在一起不久后便分手了，不过同时也让我成长了一点，可能以后不会那么容易喜欢一个人了，希望她能够找到自己的幸福吧。</p><h2 id="旅行"><a href="#旅行" class="headerlink" title="旅行"></a>旅行</h2><h3 id="关山草原研讨会"><a href="#关山草原研讨会" class="headerlink" title="关山草原研讨会"></a>关山草原研讨会</h3><p>当时六月份的时候实验室和有合作项目的公司去关山草原开会，我和另外一个大三的学长去的，每个人都需要做一个自己的近期工作汇报（不过我感觉我似乎主要是过去玩的<span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span>），我当时就把自己近期做的工作大概讲了一下，然后和公司的技术leader交流了一下使用的技术栈。</p><p><img src="https://i.loli.net/2020/01/19/4kEAXnp3KCSF5x1.png" alt="其实感觉自己有点在瞎讲"></p><p>不过说实话，收获最多的可能是这里的美景了。</p><p><img src="https://i.loli.net/2020/01/19/bETF2xPSl1QNd49.png" alt="角度问题感觉我被绳子牵着"></p><p><img src="https://i.loli.net/2020/01/19/lfqJvcp13YRodOx.png" alt="有种在欧洲农场的感觉"></p><p><img src="https://i.loli.net/2020/01/19/62W17iEBgJdCzMf.png" alt="只有🐂，没有🐏"></p><h3 id="重庆之行"><a href="#重庆之行" class="headerlink" title="重庆之行"></a>重庆之行</h3><p>八月份的时候我姐调休刚好有一周的假期所以就带上我去重庆玩了一圈，之前一直在陕西这个地方打转，这算是我第一次出省了，也是第一次坐高铁（毕竟我上大学回家直接坐公交车就到家了，所以真的不怎么出远门）。从西安到重庆五个小时，但是在动车上丝毫没有觉得时间过得慢，一路上的景色真的很好，放张在动车上拍的外边的景色吧</p><p><img src="https://i.loli.net/2020/01/19/fx5uHNlcpBih9Gg.png" alt="这会应该是在四川广元"></p><p><img src="https://i.loli.net/2020/01/19/nfd3KR9ba8Ig1Wl.png" alt="洪崖洞夜景"></p><p><img src="https://i.loli.net/2020/01/19/UYPzXnH1R5p673t.png" alt="千厮门大桥"></p><p><img src="https://i.loli.net/2020/01/19/jBhJpgQfqF1UKlo.png" alt="鹅岭公园视角，一览众山小的感觉"></p><p><img src="https://i.loli.net/2020/01/19/OZJwShoDdUjq1lI.png" alt="李子坝轻轨穿楼"></p><h2 id="鹿先森演唱会"><a href="#鹿先森演唱会" class="headerlink" title="鹿先森演唱会"></a>鹿先森演唱会</h2><p>十月份那会无意中在网易云音乐看到鹿先森乐队的全国巡演，十二月底在西安会有演唱会，刚好那会手里的实习工资还没花完，所以就二话不说买了票，静等演唱会的那天，演唱会那天和舍友gay峰（之所以叫gay峰可能是他每次在宿舍很gay吧😂）一块去的，感觉体验很好，就是人多里边有点热，非常nice,期待下次再遇鹿先森~</p><p><img src="https://i.loli.net/2020/01/19/w5TDI9EFzrxf26e.png" alt=""></p><h2 id="新的起点、新的征途"><a href="#新的起点、新的征途" class="headerlink" title="新的起点、新的征途"></a>新的起点、新的征途</h2><p>2020年对我来说将是不平常的一年，今年我二十岁了(也是全面建成小康社会的攻坚之年hhhh，回归正题)，之前一直在考研与工作之间犹豫不定，认真的分析了一下当前情况觉得还是应该再读研深造一下，家里人也非常支持我考研，同时也觉得趁着年轻多给自己镀点金有利无弊。总之可以预想到的是在接下来一年会面对很多困难，遇到很多挫折，希望自己能够更加沉得住气，养成更好的学习习惯，更加充分的利用时间，最后用自己很喜欢的一句话诫勉自己吧——修得平常心，才成非凡事。</p><p>2021考研加油，愿每个小梦想都可以实现！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度文库文档下载</title>
      <link href="/2019/12/19/bai-du-wen-ku-wen-dang-xia-zai/"/>
      <url>/2019/12/19/bai-du-wen-ku-wen-dang-xia-zai/</url>
      
        <content type="html"><![CDATA[<p>之前用过一个百度文库在线下载文档的网站，非常好用，除了付费购买的不能下载之外其他的都可以下载，所以在这里安利一下。</p><p>网址：<a href="http://www.blpack.com/" target="_blank" rel="noopener">http://www.blpack.com/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 资源分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 百度文库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器请求一个URL详细过程</title>
      <link href="/2019/12/12/liu-lan-qi-qing-qiu-yi-ge-url-xiang-xi-guo-cheng/"/>
      <url>/2019/12/12/liu-lan-qi-qing-qiu-yi-ge-url-xiang-xi-guo-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基本每个人每天都会使用到浏览器进行上网，那么在我们输入一个网址后其背后运行的原理是什么样的？如何将一个玲琅满目的网页显示出来，其中经历了一个怎样的过程，总的来说，分为以下几个过程</p><ul><li>DNS解析</li><li>HTTP请求发送</li><li>服务器处理请求并返回结果</li><li>浏览器渲染页面</li><li>连接结束</li></ul><h1 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h1><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>DNS解析就是寻找要访问的资源的IP地址，在计算机网络中是根据IP地址对每台主机进行定位的，相当于唯一的<strong>标识</strong>。比如小明是一名大学生，有一天他想要上淘宝买一个耳机，在浏览器地址栏输入后进行访问时会先在<a href="www.taobao.com"></a><strong>hosts</strong>文件中查看，没有的话再在<strong>本地DNS服务器</strong>(一般为所在地运营商机房)查询，本地DNS收到查询请求后会在缓存中查询，如果还没有的话本地DNS将向根域名服务器发送请求，根域名服务器收到请求后一看后缀是<strong>.com</strong>，好了，把.com顶级域名服务器的地址返回，你去问它吧。然后.com顶级域名服务器中将<strong>taobao.com权威域名服务器</strong>返回，权威域名服务器最终返回taobao.com对应的IP地址，下图比较详细的说明了DNS解析的过程（该图源自网络）。</p><p><img src="https://i.loli.net/2019/12/19/u6wMaQhndYpxg91.png" alt="DNS解析过程"></p><p>可使用<strong>tracert</strong>命令跟踪到URL中间的网络节点</p><pre><code>tracert www.baidu.com</code></pre><p><strong>备注：</strong>事实上可能我们大部分情况下在电脑设置里看到的本地DNS服务器地址都是192.168.XX.XX,这个大多是局域网下的路由器，而路由器也只是起到了转发的作用，将DNS请求转发到运营商机房。</p><h2 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h2><p>在做完DNS解析后浏览器也就得到了要请求的主机IP，接下来就是向该主机发送请求信息。虽然我们不用去关心具体请求是怎么发送过去的，但是在这里还是大概说一下。</p><p>在连接发送过程中，大概使用了以下网络协议</p><ul><li>TCP    与服务器建立TCP连接</li><li>IP            网络层协议，用于发送IP数据包</li><li>OPSF      路由协议，IP数据包在路由器间传递基于相应路由协议</li><li>ARP协议    用于将IP地址转换为MAC地址（物理地址唯一）</li><li>HTTP协议    应用层协议，用于发送HTTP报文请求</li></ul><p>以上过程作为不同计算机之间通信的必须协议，看来计算机底层帮我们做了太多的工作了^.^</p><p>另外，由于考虑到安全性请求，事实上我们大部分情况下访问网站都是发送的<strong>HTTPS</strong>请求</p><p><img src="https://onedrive.gimhoy.com/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBcGtNdG56TnhsVm9lZWFlWUhfUXZsbHdRbkE=.png" alt="HTTPS原理"></p><p>上图中HTTPS实现加密的过程不必详细了解，只需要知道HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，如果想要深入研究可以参考本文——<a href="https://juejin.im/post/5d53aa04f265da03934bd70c" target="_blank" rel="noopener">图解HTTPS基本原理</a></p><h2 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h2><p>服务器主机上的服务器软件（tomcat、nginx、werkzurk等）在收到请求后，会处理请求并返回HTTP响应报文</p><p>HTTP响应报文由三部分组成：状态行、响应头部、响应正文</p><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>由三部分组成——协议版本，状态码，状态码描述，之间由空格分隔，在这里列举了不同数字开头的状态码</p><ul><li><p>1xx：指示信息–表示请求已接收，继续处理。</p></li><li><p>2xx：成功–表示请求已被成功接收、理解、接受。</p></li><li><p>3xx：重定向–要完成请求必须进行更进一步的操作。</p></li><li><p>4xx：客户端错误–请求有语法错误或请求无法实现。</p></li><li><p>5xx：服务器端错误–服务器未能实现合法的请求。</p><p>我们所常见的404错误就是由于客户端发生错误</p></li></ul><h3 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h3><p>下面是一些常见的响应头部</p><table><thead><tr><th align="left">响应头</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Server</td><td align="left">服务器应用程序软件的名称和版本</td></tr><tr><td align="left">Content-Type</td><td align="left">响应正文的类型（是图片还是二进制字符串）</td></tr><tr><td align="left">Content-Charset</td><td align="left">响应正文使用的编码</td></tr><tr><td align="left">Content-Encoding</td><td align="left">响应正文使用的数据压缩格式</td></tr><tr><td align="left">Content-Language</td><td align="left">响应正文使用的语言</td></tr></tbody></table><p>响应示例</p><p><img src="https://i.loli.net/2019/12/19/vukOdIlys8pbmre.png" alt="响应头"></p><h2 id="浏览器渲染页面"><a href="#浏览器渲染页面" class="headerlink" title="浏览器渲染页面"></a>浏览器渲染页面</h2><p>在服务器处理好请求请求并返回后，浏览器会将返回的网页源码渲染出来，浏览器渲染页面基于webkit内核，先上一张图</p><p><img src="https://i.loli.net/2019/12/19/fJPeqGlQwYFvWtR.png" alt="页面渲染过程图"></p><p>从这张图，我们可以看到浏览器会解析三个东西：</p><ul><li><p>一个是HTML/SVG/XHTML，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree</p></li><li><p>CSS，解析CSS会产生CSS规则树</p></li><li><p>Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree</p></li></ul><p>在解析完成后浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree，最后通过调用操作系统Native GUI的API绘制。具体可以参考<a href="https://coolshell.cn/articles/9666.html" target="_blank" rel="noopener">浏览器的渲染原理简介</a></p><h2 id="连接结束"><a href="#连接结束" class="headerlink" title="连接结束"></a>连接结束</h2><p>在渲染完成后一次访问请求也就结束了。事实上，第一次加载网页往往比较慢，但后续加载该网页会快很多，这是因为DNS缓存和浏览器缓存等起的作用，将一些静态资源暂时缓存到本地以备下次访问使用，可以提高了页面的加载速率，用户的体验感更好。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a></li><li><a href="https://coolshell.cn/articles/9666.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9666.html</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
            <tag> HTTP </tag>
            
            <tag> 页面渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>细说ip</title>
      <link href="/2019/11/05/xi-shuo-ip/"/>
      <url>/2019/11/05/xi-shuo-ip/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在互联网中，每台计算机要实现通信的前提就是互相知道对方的地址，那么这个地址就是<strong>IP</strong>，通过IP地址我们可以很方便的在因特网上进行寻址。IP地址现在由因特网和数字分配机构ICANN(Internet Corporation for Assigned Names and Numbers)进行分配。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>按照长度分为</p><ul><li><p><strong>IPV4</strong>地址（4字节）</p></li><li><p><strong>IPV6</strong>地址（16字节）</p><p>按照用途分为</p></li><li><p>公有地址（公网ip）</p></li><li><p>私有地址（内网ip）</p></li></ul><p>另外，IP地址的编址方法一共经过了三个阶段。</p><ol><li><p>分类的IP地址，最基本的编址方法，下文将详细叙述。</p></li><li><p>子网的划分，对最基本编址方法的改进，其标准RFC 950在1985年通过。</p></li><li><p>构成超网，属于比较新的无分类编址方法，1993年提出后很快得到推广应用<br>在分类IP地址中，IP地址由两段构成，网络号与主机号</p><pre><code>   IP地址  =网络号+主机号</code></pre></li></ol><h2 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h2><blockquote><p><strong>网际协议版本4</strong>（英语：<strong>I</strong>nternet <strong>P</strong>rotocol <strong>v</strong>ersion <strong>4</strong>，缩写：<strong>IPv4</strong>，又称<strong>互联网通信协议第四版</strong>）是<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">网际协议</a>开发过程中的第四个修订版本，也是此协议第一个被广泛部署和使用的版本。</p><p>IPv4是一种<a href="https://zh.wikipedia.org/wiki/%E7%84%A1%E9%80%A3%E6%8E%A5%E5%BC%8F%E9%80%9A%E8%A8%8A" target="_blank" rel="noopener">无连接</a>的协议，操作在使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2" target="_blank" rel="noopener">分组交换</a>的链路层（如<a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91" target="_blank" rel="noopener">以太网</a>）上。此协议会尽最大努力交付数据包，意即它不保证任何数据包均能送达目的地，也不保证所有数据包均按照正确的顺序无重复地到达。这些方面是由上层的传输协议（如<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">传输控制协议</a>）处理的。</p></blockquote><p>上边的话显得太专业，可能有的小伙伴会听不懂，其实简而言之IP地址就是给因特网上的每一个主机或路由器的每个接口分配一个在全世界范围内唯一的32位的标识符（其实就差不多相当于我们的电话号码）,一个IP地址在整个因特网范围内都是唯一的。</p><h3 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h3><p>首先介绍一下A类、B类、C类网络地址，详见下图<br><img src="https://onedrive.gimhoy.com/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBcGtNdG56TnhsVm9kaXRnWGlUdDZPMmVqNVU=.png" alt=""></p><ul><li>如上图所示，A类地址中最高位为0，剩下的31位中高7位为网络标识符，主机标识位为24位，意味着每个网络可以容纳1600多万台的主机，A 类占整个地址空间的 50%。 然而，只有 126 个组织可以分配 A 类网络地址。 有趣的是，每个组织都可以为 16,000,000 台主机提供地址。 超大型组织会分配整个 A 类地址块。 时至今日，仍有公司和政府组织拥有 A 类地址。 例如，通用电气公司拥有 3.0.0.0/8，苹果电脑公司拥有 17.0.0.0/8，美国 邮政总局拥有 56.0.0.0/8。</li><li>B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码，剩下的两段号码为本地计算机的号码。如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是“10”。B类IP地址中网络的标识长度为14位，主机标识的长度为16位，B类网络地址适用于中等规模规模的网络，每个网络所能容纳的计算机数为6万多台。B 类占整个地址空间的 25%。 最多 16,384 个组织可以分配 B 类网络地址，每个网络可以支持 65,534 台主机。 只有那些特大型的公司/组织或政府部门有可能会使用到所有 65,000 个地址。 与 A 类网络类似，B 类地址空间浪费许多 IP 地址。</li><li>C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是“110”。C类IP地址中网络的标识长度为21位，主机标识的长度为8位，C类网络地址数量较多，适用于小规模的局域网络，每个网络最多只能包含254台计算机。   C 类占整个地址空间的 12.5%。 许多组织可以获得 C 类网络，但是限于它们能够连接的主机总数。 事实上，在许多情况下，C 类地址对于大多数中型企业来说通常太小。<br>看完了三类地址的简单介绍后可能会有点一头雾水，没关系，看完下边你可能更懵<br><img src="https://onedrive.gimhoy.com/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBcGtNdG56TnhsVm9kd0JQTzZkVmVBcFc2TEk=.png" alt=""></li></ul><h4 id="单播、多播、广播"><a href="#单播、多播、广播" class="headerlink" title="单播、多播、广播"></a>单播、多播、广播</h4><p>除了上面三种类型的IP地址外，还有几种特殊类型的IP地址，TCP/IP协议规定，凡IP地址中的第一个字节以“1110”开始的地址都叫多点广播地址。在这里就要说一下单播、广播、多播地址的区别。</p><blockquote><ul><li><p>单播地址是IP网络中最常见的。包含单播目标地址的分组发送给特定主机，一个这样的例子是，IP地址为192.168.1.5（源地址）的主机向IP地址为192.168.1.200（目标地址）的服务器请求网页。要发送和接收单播分组，IP分组报头中必须有一个目标IP地址，而以太网帧报头中必须有相应的目标MAC地址。IP地址和MAC地址一起将数据传输到特定的目标主机。</p></li><li><p>广播分组的目标IP地址的主机部分全为1，这意味着本地网络（广播域）中的所有主机都将接收并查看该分组。诸如ARP和DHCP等很多网络协议都使用广播。</p><p>例如：</p><p>C类网络192.168.1.0的默认子网掩码为255.255.255.0（掩码的255个数对应网络的网络地址个数），其广播地址为192.168.1.255，其主机部分为十进制数255或二进制数11111111（全为1）；</p><p>B类网络172.16.0.0的默认子网掩码为255.255.0.0，其广播地址为172.16.255.255；</p><p>A类网络10.0.0.0的默认子网掩码为255.0.0.0，其广播地址为10.255.255.255。</p><p>在以太网帧中，必须包含与广播IP地址对应的广播MAC地址。在以太网中，广播MAC地址长48位，其十六进制表示为FF-FF-FF-FF-FF-FF（全1为广播mac，主机地址为全1即广播ip地址）</p></li><li><p>多播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个多播组IP地址，多播地址范围为224.0.0.0～239.255.255.255。由于多播地址表示一组设备（有时被称为主机组），因此只能用作分组的目标地址，源地址总是为单播地址。</p></li></ul></blockquote><p>因此，任何第一个字节大于223小于240的IP地址是多点广播地址；IP地址中的每一个字节都为0的地址（“0.0.0.0”）对应于当前主机；IP地址中的每一个字节都为1的IP地址（“255．255．255．255”）是当前子网的广播地址；IP地址中凡是以“llll0”的地址都留着将来作为特殊用途使用；IP地址中不能以十进制“127”作为开头，127.0.0.1是回送地址，指本地机，一般用来测试使用。回送地址（127.x.x.x）是本机回送地址（Loopback Address）,即主机IP堆栈内部的IP地址，主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回之，不进行任何网络传输。 属于保留测试地址,不能用，同时网络ID的第一个6位组也不能全置为“0”，全“0”表示本地网络。   D 类和 E 类用于组播和保留地址。</p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>说到子网掩码就不能不提一下子网的概念，在前边的几类地址中比如我们申请到一个c类地址，那么意味着我们最多可以容纳2<sup>8</sup>-2台主机，也就是254台。那么如何对这254台主机进行进一步划分，这就引出了<strong>子网</strong>的概念</p><blockquote><p>为了确定网络区域，分开主机和路由器的每个接口，从而产生了若干个分离的网络岛，接口端连接了这些独立网络的端点。这些独立的网络岛叫做<strong>子网(subnet)。</strong></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ip </tag>
            
            <tag> 局域网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前向代理与反向代理</title>
      <link href="/2019/11/01/qian-xiang-dai-li-yu-fan-xiang-dai-li/"/>
      <url>/2019/11/01/qian-xiang-dai-li-yu-fan-xiang-dai-li/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>   代理顾名思义就是自己不去干一件事，让别人帮你去干。同样的，我们在网络上访问一些服务时也需要通过代理去完成，比如有天你想要看某某hub,但是你在China时看不到的，所以此时你便需要一个国外的代理服务器代理你去访问，然后将结果返回给你，然后你就可以嘿嘿嘿了。<br>   <img src="https://img-blog.csdnimg.cn/20190409162703561.gif" alt=""></p><p>   在这里便是代理的一种应用，其实代理按照代理的方式一般可分为前向代理与反向代理</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><h3 id="前向代理"><a href="#前向代理" class="headerlink" title="前向代理"></a>前向代理</h3>  我们所见到的大部分情况都是前向代理，A客户端表面上与B服务器进行通信，但是事实上中间可能还经过了B服务器的转发，此时B服务器就起的是代理的作用，代理服务器是面向客户端的。刚开始我们所举的例子就属于前向代理范畴，通常用于访问某些服务受限时，起到了代理转发的作用。</li><li><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3>  反向代理我们可能见的并不多，但是却起到至关重要的作用，例如著名的Nginx服务器通常就起的是反向代理的作用。当你准备网上购物时，在浏览器地址栏输入taobao.com，域名地址经过DNS服务器解析后便可访问到对应的网站，这只是一个宏观上的过程，事实上在此过程中浏览器拿到服务器ip地址后便向服务器发送http请求，此时接受请求的就是nginx服务器(也可能是其他服务器，例如Apache等)，而nginx接收到请求后自己并不能处理请求，需要将请求转发到对应的web应用层进行处理，在进行完逻辑处理后，web应用层把请求返回给nginx,说：‘nginx，你可以把结果返回到客户端了’，nginx便乖乖的将结果返回到客户端，这便是反向代理在其中所起到的作用，隐匿了真正的业务逻辑层，提高了应用层安全性。<h5 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h5><ul><li>对客户端隐藏服务器（集群）的IP地址</li><li>安全：作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等</li><li>为后端服务器（集群）统一提供加密和SSL加速（如SSL终端代理）</li><li>负载均衡，若服务器集群中有负荷较高者，反向代理通过URL重写，根据连线请求从负荷较低者获取与所需相同的资源或备援</li><li>对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务<br>对一些内容进行压缩，以节约带宽或为网络带宽不佳的网络提供服务</li><li>减速上传</li><li>为在私有网络下（如局域网）的服务器集群提供NAT穿透及外网发布服务</li><li>提供HTTP访问认证[2]</li><li>突破互联网封锁（不常用，因为反向代理与客户端之间的连线不一定是加密连线，非加密连线仍有遭内容审查进而遭封禁的风险；此外面对针对域名的关键字过滤、DNS缓存污染/投毒攻击乃至深度数据包检测也无能为力）<h5 id="常见反向代理软件"><a href="#常见反向代理软件" class="headerlink" title="常见反向代理软件"></a>常见反向代理软件</h5></li><li>Nginx、Tengine</li><li>Apache HTTP Server</li><li>Varnish cache</li><li>Squid Cache</li><li>Traffic Server</li><li>HAProxy</li><li>YXORP</li><li>Polipo</li><li>Privoxy</li><li>IIS<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><a href="https://zh.m.wikipedia.org/zh-hans/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">维基百科-反向代理</a></li></ul></li></ul><p>​    </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单TCP服务器构建</title>
      <link href="/2019/11/01/jian-dan-tcp-fu-wu-qi-gou-jian/"/>
      <url>/2019/11/01/jian-dan-tcp-fu-wu-qi-gou-jian/</url>
      
        <content type="html"><![CDATA[<h2 id="一-基本概念"><a href="#一-基本概念" class="headerlink" title="一.基本概念"></a>一.基本概念</h2><ul><li><strong>Socket(套接字）</strong></li></ul><blockquote><p> socket是一种操作系统提供的进程间通信机制。[1] 在操作系统中，通常会为应用程序提供一组应用程序接口（API），称为套接字接口（英语：socket API）。应用程序可以通过套接字接口，来使用网络套接字，以进行数据交换。最早的套接字接口来自于4.2 BSD，因此现代常见的套接字接口大多源自Berkeley套接字（Berkeley sockets）标准。在套接字接口中，以IP地址及通信端口组成套接字地址（socket address）。远程的套接字地址，以及本地的套接字地址完成连线后，再加上使用的协议（protocol），这个五元组（five-element tuple），作为套接字对（socket pairs），之后就可以彼此交换数据。例如，在同一台计算机上，TCP协议与UDP协议可以同时使用相同的port而互不干扰。<br>  操作系统根据套接字地址，可以决定应该将数据送达特定的行程或线程。这就像是电话系统中，以电话号码加上分机号码，来决定通话对象一般。<br> 材料来源：维基百科 </p></blockquote><p> 套接字顾名思义就是像插座一样起到了套接的作用。我们知道当不同的两台计算机进行通信时，需要通过彼此的ip地址进行寻址通信，但是计算机上面运行的软件很多，比如在你开微信的时候还听着歌，那么不同的应用程序进行通信时是如何做到互不影响的呢？这就是端口的用途，或许你觉得你可能用不到这个玩意，当你在网上输入任意一个网址时，浏览器都默认给网址的最后加上<strong>80(http协议通信默认端口)</strong>,程序便可以通过端口进行通信，传递信息。</p><ul><li><strong>TCP协议</strong><br> TCP为传输控制协议，我们所遇到的大部分通信都是基于TCP协议的可靠通信，TCP连接之所以可靠是因为TCP建立的是长连接，创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。<h2 id="二-实现原理"><a href="#二-实现原理" class="headerlink" title="二.实现原理"></a>二.实现原理</h2><ul><li><strong>创建socket</strong><br><img src="https://img-blog.csdnimg.cn/20190513171805553.png" alt=""><br>在这里我们直接导入socket模块，然后创建socket对象，socket类初始化时需要赋参数，因为我们这里创建的是TCP服务，所以就不应改动，如果创建Udp服务时则应该改为family=AF_INET,type=SOCK_DGRAM</li></ul></li></ul><p> <strong>socket类构建方法参数类型</strong><br><img src="https://img-blog.csdnimg.cn/20190513172445518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><ul><li><strong>客户端请求连接</strong><br>在这里为了简化，我直接使用socket测试工具进行连接，并发送数据‘hello’<br>accept()方法可以返回一个元组，为一个新的套接字与客户端ip地址与端口，之所以需要返回一个新的套接字是因为为了满足下一次的通信需要，如果使用一个套接字时那么当发送来别的请求时将无法继续监听，因为此时的socket正在使用，所以需要新建一个通信管道。<br><img src="https://img-blog.csdnimg.cn/20190513173044910.png" alt=""><h2 id="三-方法改进"><a href="#三-方法改进" class="headerlink" title="三.方法改进"></a>三.方法改进</h2>上面我们是从最底层建立TCP连接(即从建立最基本的socket开始),事实上在真正的开发中程序员很少去从最底层做，因为已经有了封装的比较好的类库，从而避免了重复造轮子，在这里我们将使用socketserver模块中的服务基类与请求处理基类实现该功能<br><img src="https://img-blog.csdnimg.cn/20190513174407801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""><br>这样我们便不用去关心底层建立socket的细节，而只关心业务逻辑的处理，使用TCPServer类有一个缺陷，就是只能为一个客户端服务，是单线程的，当我们想要创建多线程连接时可以使用<strong>ThreadingTCPServer</strong>类来满足。<br>另外，当我们想要去调整底部的socket时可以设置参数<strong>bind_and_activate=False</strong><br><img src="https://img-blog.csdnimg.cn/2019051317493676.png" alt=""></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中引用文件的方法</title>
      <link href="/2019/10/31/python-zhong-yin-yong-wen-jian-de-fang-fa/"/>
      <url>/2019/10/31/python-zhong-yin-yong-wen-jian-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr><p>在程序中引用文件无非是通过两种方式——<strong>绝对路径与相对路径</strong>，但是前者往往因为文件目录的改动而造成引用错误，因此我们大多采用相同路径的文件来引用文件。</p><p>例如，我们当前的目录结构是这样的</p><pre class=" language-python"><code class="language-python"><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>GUI    <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>test        <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>demo<span class="token punctuation">.</span>py        <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>file<span class="token punctuation">.</span>json    <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span>api<span class="token punctuation">.</span>py</code></pre><p>在demo.py中有函数<strong>read_data()</strong>来读取file.json中的内容</p><pre class=" language-python"><code class="language-python">read_data<span class="token punctuation">(</span>file_path<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">with</span> open<span class="token punctuation">(</span>file_path<span class="token punctuation">,</span>mode<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> json_file<span class="token punctuation">:</span>            config<span class="token operator">=</span>json<span class="token punctuation">.</span>load<span class="token punctuation">(</span>json_file<span class="token punctuation">)</span>            <span class="token keyword">return</span> config        <span class="token keyword">except</span> FileNotFoundError <span class="token keyword">as</span> e<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span></code></pre><p>其中将file_path改为<strong>“./file.json”</strong>即可读取file.json中内容</p><p>那么现在我们在api.py中调用demo.py发现会报如下错误：</p><blockquote><p>找不到file.json</p></blockquote><p>？？？？什么鬼？</p><p>我们的文件路径经过开始的测试没有错误啊，为什么会出现这样的错误？</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><hr><p>事实上，我们的相对文件路径并没有错，当然这是建立在脚本程序和所读文件在相同的目录下，但是由于我们在其他目录下引用了相对路径，那么就会产生一个问题：python解释器在执行api.py时在api.py的父级目录下找不到file.json,因此便会报错，那么有什么方法可以让文件的路径始终保持唯一不变呢？请看下面</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> oscurrent_path<span class="token operator">=</span>os<span class="token punctuation">.</span>path<span class="token punctuation">.</span>dirname<span class="token punctuation">(</span>__file__<span class="token punctuation">)</span>read_data<span class="token punctuation">(</span>file_path<span class="token punctuation">)</span><span class="token punctuation">:</span>    full_path<span class="token operator">=</span>current_path<span class="token operator">+</span>file_path    <span class="token keyword">try</span><span class="token punctuation">:</span>        <span class="token keyword">with</span> open<span class="token punctuation">(</span>full_path<span class="token punctuation">,</span>mode<span class="token operator">=</span><span class="token string">'r'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> json_file<span class="token punctuation">:</span>            config<span class="token operator">=</span>json<span class="token punctuation">.</span>load<span class="token punctuation">(</span>json_file<span class="token punctuation">)</span>            <span class="token keyword">return</span> config        <span class="token keyword">except</span> FileNotFoundError <span class="token keyword">as</span> e<span class="token punctuation">:</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span></code></pre><p>在其中我们对前面的代码进行了改动，加入了<strong>os.path.dirname(<strong>file</strong>)返回了该函数所在的脚本文件的路径,</strong>因而在其他模块中进行调用时便可直接找到该文件</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树及哈夫曼编码详解</title>
      <link href="/2019/10/25/ha-fu-man-shu-ji-ha-fu-man-bian-ma-xiang-jie/"/>
      <url>/2019/10/25/ha-fu-man-shu-ji-ha-fu-man-bian-ma-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><blockquote><p>在讲哈夫曼树之前先来介绍一下哈夫曼编码的概念。在信息编码、数据压缩等方面，我们总是希望编码能够尽可能的简短一点，如此才能节省空间，提高传输效率。例如：如果采用等长编码的话编码’abcd’,则为00，01，10，11，此时占据8bit的空间，况且各个字符出现的频率还都为一次，如果出现多次则会效率很低；如果采用不等长编码的话则可以为：0，10，110，111，大家肯定会有一个问题：为什么要写成这种形式呢？如果我分别编码为0，1，00，01的话可以吗？那么假如编码串为”001011”的话计算机便不能进行唯一的解码了，因为此时可能的结果有’aababb’,’addb’,’cbdb’,因此如果没有分隔符标注的话便会产生歧义。所以此时引入了一个<strong>前缀编码</strong>的概念——<strong>同一字符集中任何一个字符的编码都不是另外一个字符编码的前缀（最左字串），这种编码称为前缀编码。</strong></p></blockquote><hr><p>在真正压缩的时候我们希望出现频率高的字符所占用较小的编码长度，如果之前你学过离散数学的话应该会听过<strong>最优二叉树</strong>的概念，即让权值小的元素靠近根结点，哈夫曼树便是这个原理。</p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><blockquote><p>路径：从树中一个结点到另一个结点之间的分支序列构成两个结点间的路径。</p><p>路径长度：路径上分支的条数称为路径长度。</p><p>树的路径长度：从树根到每个结点的路径长度之和称为树的路径长度。</p><p>结点的权：给树中结点赋予一个数值，该数值称为结点的权。</p><p>带权路径长度：结点到树根间的路径长度与结点权的乘积，称为该结点的带权路径长度。</p><p>树的带权路径长度：树中所有叶子结点的带权路径长度之和，称为树的带权路径长度，通常记为WPL</p><p>​                                                          <img src="https://private.codecogs.com/gif.latex?WPL%3D%20%5Csum_%7Bk%3D1%7D%5E%7Bn%7DW_%7Bk%7D*L_%7Bk%7D" alt=""></p><p>注：n为叶子结点个数（所要编码的字符数）</p></blockquote><p>在这里，最优二叉树的写法不在赘述，具体可参考：<a href="https://jingyan.baidu.com/article/380abd0a717c061d90192ca2.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/380abd0a717c061d90192ca2.html</a></p><h2 id="哈夫曼树的建立与编译码"><a href="#哈夫曼树的建立与编译码" class="headerlink" title="哈夫曼树的建立与编译码"></a>哈夫曼树的建立与编译码</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>哈夫曼树中没有度为1的结点，故n个叶子的哈夫曼树，恰有n-1个度为2的结点，所以哈夫曼树共有2n-1个结点，可以存储在一个大小为2n-1的一维数组中。</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Weight</td><td>Parent</td><td>Lchild</td><td>Rchild</td></tr></tbody></table><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//结构声明</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> point<span class="token punctuation">{</span>    <span class="token keyword">int</span> weight<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//权值</span>    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//父节点下标</span>    <span class="token keyword">char</span> data<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//编码字母</span>    <span class="token keyword">int</span> code<span class="token punctuation">;</span>           <span class="token keyword">int</span> lchild<span class="token punctuation">,</span>rchild<span class="token punctuation">;</span><span class="token punctuation">}</span>HuffmanNode<span class="token punctuation">;</span></code></pre><h3 id="建立哈夫曼树"><a href="#建立哈夫曼树" class="headerlink" title="建立哈夫曼树"></a>建立哈夫曼树</h3><p>​     1.在建立前我们需要对每个字符求其权值，在这里我们以字符出现的频度作为权值的衡量标准。</p><pre class=" language-cpp"><code class="language-cpp">HuffmanNode <span class="token operator">*</span><span class="token function">Compute_weight</span><span class="token punctuation">(</span>HuffmanNode <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//计算权值</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt=""></p><p>   2.利用其权值大小创建哈夫曼树</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">Build_HuffmanTree</span><span class="token punctuation">(</span>HuffmanNode <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//建立哈夫曼树</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span><span class="token operator">*</span>min<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        min<span class="token operator">=</span><span class="token function">SearchMinNumbers</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s1<span class="token operator">=</span><span class="token operator">*</span>min<span class="token punctuation">;</span>        s2<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>min<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">=</span>p<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">+</span>p<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>        p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token operator">=</span>s1<span class="token punctuation">;</span>        p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild<span class="token operator">=</span>s2<span class="token punctuation">;</span>        p<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span>i<span class="token punctuation">;</span>        p<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span>i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt=""></p><p>3.哈夫曼树编码</p><p>​      此时我们规定左分支表示‘0’，右分支表示‘1’，用根结点到叶子结点路径上的分支符号组成的串，作为叶子节点字符的编码，这就是哈夫曼编码。</p><pre class=" language-cpp"><code class="language-cpp">HuffmanNode <span class="token function">ResolveHuffmanCode</span><span class="token punctuation">(</span>HuffmanNode <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//打印字符编码</span><span class="token punctuation">{</span>    HuffmanNode ptemp<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>code<span class="token punctuation">;</span>    <span class="token keyword">int</span> start<span class="token punctuation">,</span>pre<span class="token punctuation">;</span>    code<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">mallco</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    code<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'\0'</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        start<span class="token operator">=</span>n<span class="token number">-1</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        ptemp<span class="token operator">=</span>i<span class="token punctuation">;</span>        pre<span class="token operator">=</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token operator">==</span>ptemp<span class="token punctuation">)</span>                code<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                code<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">;</span>            ptemp<span class="token operator">=</span>pre<span class="token punctuation">;</span>            pre<span class="token operator">=</span>p<span class="token punctuation">[</span>ptemp<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>            start<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt=""></p><p>4.哈夫曼树译码</p><p>哈夫曼译码过程较为简单，可按照编码表采用朴素字符串比对的方法进行解码，但是建议采用KMP算符进行字符串匹配，效率较高</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈夫曼树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫之有道翻译</title>
      <link href="/2019/10/22/python-pa-chong-zhi-you-dao-fan-yi/"/>
      <url>/2019/10/22/python-pa-chong-zhi-you-dao-fan-yi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自从学了python之后，终于明白了那句“人生苦短，我用python”是什么意思了，哈哈，废话不多说，下文正式开始模拟用户翻译过程。</p><h2 id="审查请求元素"><a href="#审查请求元素" class="headerlink" title="审查请求元素"></a>审查请求元素</h2><p>我们在浏览网站时，往往会需要从网站服务器上请求或者向网站服务器提交一些数据，此时我们的浏览器主要向服务器发送get请求来获取数据，或者发送post请求来提交数据，简而言之，我们可以将这样的用户使用情景模拟出来，下面以有道翻译为例：</p><p><img src="https://img-blog.csdnimg.cn/20190206164514445.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>在图中可以看到，当用户点击翻译按钮时，浏览器会自动以form_data的形式向服务器发起post请求，发送一些翻译需要的信息，而服务器在接受到请求后会对该请求进行校验，如果检测到是以代码程序的形式进行请求则会进行限制（这个事实上我们填写headers就ok了），或者同一个ip在短时间内大量访问就会被直接封掉（这个问题我们此时不考虑）。在识别为合法的请求后服务器会将结果返回客户端，一般情况下都是json格式</p><p><img src="https://img-blog.csdnimg.cn/2019020617113187.png" alt=""></p><p>此时我们将相关信息提取出来copy到代码里。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>request  <span class="token comment" spellcheck="true">#导入模块</span><span class="token keyword">import</span> urllib<span class="token punctuation">.</span>parse<span class="token keyword">import</span> jsoncontent<span class="token operator">=</span>input<span class="token punctuation">(</span><span class="token string">"请输入要翻译的内容："</span><span class="token punctuation">)</span>head<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">#请求头信息</span>head<span class="token punctuation">[</span><span class="token string">'User-Agent'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36'</span>url<span class="token operator">=</span><span class="token string">'http://fanyi.youdao.com/translate?smartresult=dict&amp;smartresult=rule'</span>data<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">#请求表单</span>data<span class="token punctuation">[</span><span class="token string">'i'</span><span class="token punctuation">]</span><span class="token operator">=</span>contentdata<span class="token punctuation">[</span><span class="token string">'from'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'AUTO'</span>data<span class="token punctuation">[</span><span class="token string">'to'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'AUTO'</span>data<span class="token punctuation">[</span><span class="token string">'smartresult'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'dict'</span>data<span class="token punctuation">[</span><span class="token string">'client'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'fanyideskweb'</span>data<span class="token punctuation">[</span><span class="token string">'salt'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'15494388925757'</span>data<span class="token punctuation">[</span><span class="token string">'sign'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'00b84e93f30570e331c01318f59a47f0'</span>data<span class="token punctuation">[</span><span class="token string">'ts'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'1549438892575'</span>data<span class="token punctuation">[</span><span class="token string">'bv'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'e40fbeed3cd61fe519ae6051fcce0429'</span>data<span class="token punctuation">[</span><span class="token string">'doctype'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'json'</span>data<span class="token punctuation">[</span><span class="token string">'version'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'2.1'</span>data<span class="token punctuation">[</span><span class="token string">'keyfrom'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'fanyi.web'</span>data<span class="token punctuation">[</span><span class="token string">'action'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'FY_BY_CLICKBUTTION'</span>data<span class="token punctuation">[</span><span class="token string">'typoResult'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'false'</span>data<span class="token operator">=</span>urllib<span class="token punctuation">.</span>parse<span class="token punctuation">.</span>urlencode<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>req<span class="token operator">=</span>urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>Request<span class="token punctuation">(</span>url<span class="token punctuation">,</span>data<span class="token punctuation">,</span>head<span class="token punctuation">)</span>response<span class="token operator">=</span>urllib<span class="token punctuation">.</span>request<span class="token punctuation">.</span>urlopen<span class="token punctuation">(</span>req<span class="token punctuation">)</span>html<span class="token operator">=</span>response<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span>trans<span class="token operator">=</span>json<span class="token punctuation">.</span>loads<span class="token punctuation">(</span>html<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#加载为json字典对象</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"翻译结果:"</span><span class="token punctuation">,</span>trans<span class="token punctuation">[</span><span class="token string">'translateResult'</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token string">'tgt'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>url信息我们在post请求中就可以找到，需要注意的是有道翻译的url里边有’_o’的话去掉，应该是对接口进行了升级，我们用旧的接口就好了，data是一个字典，我们直接将form表单中元素copy过来就好了，在这里我们也可以不使用head，直接对url进行请求，但是此种做法容易使得服务器判断出来是机器在爬取而被直接屏蔽，因此我们最好配置user-agent信息。此外<strong>req=urllib.request.Request(url,data,head)</strong>使用了request类，来对我们的请求头进行包装，为请求增加了head信息，使得爬虫更加安全，<strong>但是最安全的方法则是控制访问的时间或者使用代理ip.</strong></p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="https://img-blog.csdnimg.cn/20190206170647280.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 爬虫 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>java构造器调用顺序</title>
      <link href="/2019/10/21/java-gou-zao-qi-diao-yong-shun-xu/"/>
      <url>/2019/10/21/java-gou-zao-qi-diao-yong-shun-xu/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在看书的时候，看到了关于继承的知识，突然觉得之前的理解还是不够，就想着把学到的关于构造器的知识记录下来</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>相信大部分人都知道java里边的构造器在做一件什么样的事———创建实例对象时进行初始化，比如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">boolean</span> is_man<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       Test test<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt=""></p><p>上边这段代码在做着一件简简单单的事情，在堆内存中申请一块内存，创建类的实体对象并为变量赋初值（数值型为0，布尔型为false）。很多人会认为执行构造器方法就是在创建方法，事实上在构造器方法执行前系统已经创建了对象，只不过该对象当前还不能被外界访问而已，构造器函数当前只是执行了成员变量的初始化功能。</p><h2 id="继承中的构造器"><a href="#继承中的构造器" class="headerlink" title="继承中的构造器"></a>继承中的构造器</h2><p>在这里有一个很典型的例子</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String msg<span class="token operator">=</span><span class="token string">"I'am animal"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Animal</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">" belongs to animal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String msg<span class="token operator">=</span><span class="token string">"I'am human"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Human</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Human</span><span class="token punctuation">(</span><span class="token keyword">int</span> history<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">"horse"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Human society has a long history about "</span><span class="token operator">+</span>history<span class="token operator">+</span><span class="token string">" years"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String msg<span class="token operator">=</span><span class="token string">"I'am a woman"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt=""></p><p>上边的程序生动的展现了类继承树中构造器方法的调用顺序，当创建一个子类对象时，系统会依次向上回溯，从继承树顶端的Object类的构造器开始执行，依次往下执行，当在子类中显式调用重载的父类构造器函数时，便不再执行默认的构造器，如果未显式调用时则执行默认的构造器函数，上面代码的执行结果如下：</p><pre><code>horse belongs to animalHuman society has a long history about 5000 yearsI'am a woman</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt=""></p><p>最后，重要的事情说三遍：</p><p><strong>创建子类对象时没有创建父类对象，只是执行了父类的构造器函数！</strong></p><p><strong>创建子类对象时没有创建父类对象，只是执行了父类的构造器函数！</strong></p><p><strong>创建子类对象时没有创建父类对象，只是执行了父类的构造器函数！</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 构造器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>==、equals、hashcode的区别</title>
      <link href="/2019/10/10/equals-hashcode-de-qu-bie/"/>
      <url>/2019/10/10/equals-hashcode-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git详细步骤</title>
      <link href="/2019/06/05/git-xiang-xi-bu-zou/"/>
      <url>/2019/06/05/git-xiang-xi-bu-zou/</url>
      
        <content type="html"><![CDATA[<p><strong>基本用法</strong></p><p><img src="https://img-blog.csdnimg.cn/20191014104801597.png" alt=""></p><p>上面的四条命令在工作目录、暂存目录(也叫做索引)和仓库之间复制文件</p><ol><li>git add <em>files</em> 把当前文件放入暂存区域</li><li>git commit 给暂存区域生成快照并提交</li><li>git reset – <em>files</em> 用来撤销最后一次git add <em>files</em>，你也可以用git reset 撤销所有暂存区域文件</li><li>git checkout – <em>files</em> 把文件从暂存区域复制到工作目录，用来丢弃本地修改</li></ol><p><strong>你可以用</strong> <strong>git reset -p,</strong> <strong>git checkout -p, or</strong> <strong>git add -p进入交互模式。</strong></p><p><strong>也可以跳过暂存区域直接从仓库取出文件或者直接提交代码。</strong></p><p><img src="https://img-blog.csdnimg.cn/20191014104801637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>命令详解</strong></p><p><strong>Diff</strong></p><p>查看两次提交之间的变动</p><p><img src="https://img-blog.csdnimg.cn/20191014104801640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>Commit</strong></p><p>提交时，git用暂存区域的文件创建一个新的提交，并把此时的节点设为父节点。然后把当前分支指向新的提交节点。下图中，当前分支是<em>master</em>。 在运行命令之前，<em>master</em>指向<em>ed489</em>，提交后，<em>master</em>指向新的节点<em>f0cec</em>并以<em>ed489</em>作为父节点。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>即便当前分支是某次提交的祖父节点，git会同样操作。下图中，在<em>master</em>分支的祖父节点<em>maint</em>分支进行一次提交，生成了<em>1800b</em>。 这样，<em>maint</em>分支就不再是<em>master</em>分支的祖父节点。此时合并(或者衍合) 是必须的。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>如果想更改一次提交，使用 git commit –amend。git会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>另一个例子是分离HEAD提交,后文讲。</p><p><strong>Checkout</strong></p><p>checkout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。</p><p>当给定某个文件名（或者打开-p选项，或者文件名和-p选项同时打开）时，git会从指定的提交中拷贝文件到暂存区域和工作目录。比如，git checkout HEAD~ foo.c会将提交节点<em>HEAD~</em>(即当前提交节点的父节点)中的foo.c复制到工作目录并且加到暂存区域中。（如果命令中没有指定提交节点，则会从暂存区域中拷贝内容。）注意当前分支不会发生变化。</p><p><img src="https://img-blog.csdnimg.cn/2019101410480124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>当不指定文件名，而是给出一个（本地）分支时，那么<em>HEAD</em>标识会移动到那个分支（也就是说，我们”切换”到那个分支了），然后暂存区域和工作目录中的内容会和<em>HEAD</em>对应的提交节点一致。新提交节点（下图中的a47c3）中的所有文件都会被复制（到暂存区域和工作目录中）；只存在于老的提交节点（ed489）中的文件会被删除；不属于上述两者的文件会被忽略，不受影响。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、SHA-1值或者是像<em>master~3</em>类似的东西，就得到一个匿名分支，称作<em>detached HEAD</em>（被分离的<em>HEAD</em>标识）。这样可以很方便地在历史版本之间互相切换。比如说你想要编译1.6.6.1版本的git，你可以运行git checkout v1.6.6.1（这是一个标签，而非分支名），编译，安装，然后切换回另一个分支，比如说git checkout master。然而，当提交操作涉及到”分离的HEAD”时，其行为会略有不同，详情见在下面。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>HEAD标识处于分离状态时的提交操作</strong></p><p>当<em>HEAD</em>处于分离状态（不依附于任一分支）时，提交操作可以正常进行，但是不会更新任何已命名的分支。(你可以认为这是在更新一个匿名分支。)</p><p><img src="https://img-blog.csdnimg.cn/20191014104801714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>一旦此后你切换到别的分支，比如说<em>master</em>，那么这个提交节点（可能）再也不会被引用到，然后就会被丢弃掉了。注意这个命令之后就不会有东西引用<em>2eecb</em>。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>但是，如果你想保存这个状态，可以用命令git checkout -b <em>name</em>来创建一个新的分支。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>Reset</strong></p><p>eset 命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。</p><p>如果不给选项，那么当前分支指向到那个提交。如果用–hard选项，那么工作目录也更新，如果用–soft选项，那么都不变。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>如果没有给出提交点的版本号，那么默认用<em>HEAD</em>。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用–hard选项，工作目录也同样。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>如果给了文件名(或者 -p选项), 那么工作效果和带文件名的 heckout 差不多，除了索引被更新。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>Merge</strong></p><p>merge 命令把不同分支合并起来。合并前，索引必须和当前提交相同。如果另一个分支是当前提交的祖父节点，那么合并命令将什么也不做。 另一种情况是如果当前提交是另一个分支的祖父节点，就导致<em>fast-forward</em>合并。指向只是简单的移动，并生成一个新的提交。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>否则就是一次真正的合并。默认把当前提交(<em>ed489</em> 如下所示)和另一个提交(<em>33104</em>)以及他们的共同祖父节点(<em>b325c</em>)进行一次<a href="http://en.wikipedia.org/wiki/Three-way_merge" target="_blank" rel="noopener">三方合并</a>。结果是先保存当前目录和索引，然后和父节点<em>33104</em>一起做一次新提交。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>Cherry Pick</strong></p><p>cherry-pick命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>Rebase</strong></p><p>衍合是合并命令的另一种选择。合并把两个父分支合并进行一次提交，提交历史不是线性的。衍合在当前分支上重演另一个分支的历史，提交历史是线性的。 本质上，这是线性化的自动的 cherry-pick</p><p><img src="https://img-blog.csdnimg.cn/20191014104801874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>上面的命令都在<em>topic</em>分支中进行，而不是<em>master</em>分支，在<em>master</em>分支上重演，并且把分支指向新的节点。注意旧提交没有被引用，将被回收。</p><p>要限制回滚范围，使用–onto选项。下面的命令在<em>master</em>分支上重演当前分支从<em>169a6</em>以来的最近几个提交，即<em>2c33a</em>。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>同样有git rebase –interactive让你更方便的完成一些复杂操作，比如丢弃、重排、修改、合并提交。没有图片体现这些，细节看这里:<a href="http://www.kernel.org/pub/software/scm/git/docs/git-rebase.html#_interactive_mode" target="_blank" rel="noopener">git-rebase(1)</a></p><p><strong>技术说明</strong></p><p>文件内容并没有真正存储在索引(<em>.git/index</em>)或者提交对象中，而是以blob的形式分别存储在数据库中(<em>.git/objects</em>)，并用SHA-1值来校验。 索引文件用识别码列出相关的blob文件以及别的数据。对于提交来说，以树(<em>tree</em>)的形式存储，同样用对于的哈希值识别。树对应着工作目录中的文件夹，树中包含的 树或者blob对象对应着相应的子目录和文件。每次提交都存储下它的上一级树的识别码。</p><p>如果用detached HEAD提交，那么最后一次提交会被the reflog for HEAD引用。但是过一段时间就失效，最终被回收，与git commit –amend或者git rebase很像。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列与堆栈的两种实现</title>
      <link href="/2019/06/03/dui-lie-yu-dui-zhan-de-liang-chong-shi-xian/"/>
      <url>/2019/06/03/dui-lie-yu-dui-zhan-de-liang-chong-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这篇博文主要是回顾了一下之前数据结构的知识，使用单链表与数组的方式分别实现了堆栈与队列。</p><h3 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h3><p>逻辑结构顾名思义就是人们抽象出来的结构，通常包含</p><ul><li>集合结构：集合结构的集合中任何两个数据元素之间都没有逻辑关系，组织形式松散</li><li>线性结构：数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构</li><li>图结构</li><li>树状结构：树状结构是一个或多个节点的有限集合</li></ul><p>其中习惯分为两类——<strong>线性结构</strong>与<strong>非线性结构</strong>（集合结构、树、图）</p><p>而物理结构就是数据实际的存储结构包括顺序存储结构（数组）与链式存储结构（链表等），因此分别采用两种存储结构实现栈与队列。</p><h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><p><strong>堆栈</strong>是一种先进后出的结构，生活中的例子似乎不太多，不过还是有一些例子，比如一摞碗，每次取的时候总是取得最上边的碗，最下边的碗总是最后一个被取走。<strong>队列</strong>是一种先进先出的结构，生活中例子很多，最常见的就是排队了，排在前边的人先被服务，后边的人最后被服务。</p><h2 id="节点结构与接口声明"><a href="#节点结构与接口声明" class="headerlink" title="节点结构与接口声明"></a>节点结构与接口声明</h2><p>每个节点有数据域与指针域，栈与队列类实现了添加、弹出、求长度、判断为空等接口方法</p><h3 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//节点类</span><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> Object data<span class="token punctuation">;</span>    <span class="token keyword">public</span> Node next<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span>Object data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token operator">=</span>data<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="接口声明"><a href="#接口声明" class="headerlink" title="接口声明"></a>接口声明</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Stack</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/*堆栈接口*/</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//压入堆栈</span>    <span class="token keyword">public</span> Node <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//弹出堆栈</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//计算堆栈元素个数</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//求元素索引1</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//判断堆栈是否为空</span><span class="token punctuation">}</span><span class="token keyword">interface</span> <span class="token class-name">Queue</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//队列接口声明</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//队列长度</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//队列是否为空</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//求某个元素索引</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//添加元素</span>    <span class="token keyword">public</span> Node <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//弹出元素</span><span class="token punctuation">}</span></code></pre><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><h3 id="链表结构（头插法）"><a href="#链表结构（头插法）" class="headerlink" title="链表结构（头插法）"></a>链表结构（头插法）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//堆栈类（单链表-头插法）</span><span class="token keyword">class</span> <span class="token class-name">StackList</span> <span class="token keyword">implements</span> <span class="token class-name">Stack</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> Node head<span class="token operator">=</span>null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">StackList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        head<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//初始化头指针</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Node temp<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next<span class="token operator">=</span>node<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>next<span class="token operator">=</span>temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//队列为空报错</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"当前队列为空，请先添加元素！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//循环计数器</span>        <span class="token keyword">boolean</span> isMatch<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//是否匹配成功标志</span>        Node temp<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token operator">==</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//地址相同即为相同对象</span>                isMatch<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isMatch<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"当前队列没有该元素！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Node <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"当前堆栈为空！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Node temp<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">return</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        Node temp<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="数组结构"><a href="#数组结构" class="headerlink" title="数组结构"></a>数组结构</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//堆栈类（数组实现）</span><span class="token keyword">class</span> <span class="token class-name">StackArray</span> <span class="token keyword">implements</span> <span class="token class-name">Stack</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//当前堆栈中元素个数</span>    <span class="token keyword">private</span> Node<span class="token punctuation">[</span><span class="token punctuation">]</span> head<span class="token operator">=</span>null<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//数组首指针</span>    <span class="token keyword">public</span> <span class="token function">StackArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxsize<span class="token punctuation">)</span><span class="token punctuation">{</span>        head<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>maxsize<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size<span class="token operator">>=</span>head<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"堆栈已满！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        head<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span><span class="token operator">=</span>node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Node <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"堆栈为空！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> head<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//循环标志</span>        <span class="token keyword">boolean</span> isMatch<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//查找成功标志</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>                isMatch<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isMatch<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"该元素不存在！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> size<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="链表结构（尾插法）"><a href="#链表结构（尾插法）" class="headerlink" title="链表结构（尾插法）"></a>链表结构（尾插法）</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//队列类（单链表实现-尾插法）</span><span class="token keyword">class</span> <span class="token class-name">QueueList</span> <span class="token keyword">implements</span> <span class="token class-name">Queue</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Node head<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">QueueList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        head<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//计算队列长度（不包含头节点）</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        Node temp<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//队列是否为空</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> head<span class="token punctuation">.</span>next<span class="token operator">==</span>null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//查找节点位置索引</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//队列为空报错</span>             <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"当前队列为空，请先添加元素！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//循环计数器</span>        <span class="token keyword">boolean</span> isMatch<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//是否匹配成功标志</span>        Node temp<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token operator">==</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//地址相同即为相同对象</span>                isMatch<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isMatch<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"当前队列没有该元素！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//添加节点</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        Node temp<span class="token operator">=</span>head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span>next<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            temp<span class="token operator">=</span>temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>temp<span class="token operator">==</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"该元素已经添加过！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        temp<span class="token punctuation">.</span>next<span class="token operator">=</span>node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//弹出节点</span>    <span class="token keyword">public</span> Node <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        Node tempNode<span class="token operator">=</span>null<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"队列为空！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            tempNode<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            head<span class="token punctuation">.</span>next<span class="token operator">=</span>head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> tempNode<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="数组结构（循环数组）"><a href="#数组结构（循环数组）" class="headerlink" title="数组结构（循环数组）"></a>数组结构（循环数组）</h3><p>在使用数组实现队列时容易形成<strong>假满</strong>现象，设想一下一个数组里元素为满的情况下从数组首元素开始出队列，直到剩下最后一个元素，若此时需要添加新的元素因为尾部已经没有空间，所以造成了空间浪费，因而采用循环数组的形式实现。</p><p><img src="https://i.loli.net/2020/01/30/PKje7TAEwH1hdn8.png" alt="循环队列"></p><p>实现的方法主要是下一个位置对数组长度求余，比如数组长度为5，当前数组最后一个位置刚填入一个元素，那么下次的位置应该为0号位置（5%5=0）。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//队列类（循环数组实现）</span><span class="token keyword">class</span> <span class="token class-name">QueueArray</span> <span class="token keyword">implements</span> <span class="token class-name">Queue</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> Length<span class="token punctuation">;</span>    <span class="token keyword">private</span> Node<span class="token punctuation">[</span><span class="token punctuation">]</span> head<span class="token operator">=</span>null<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//数组结构时实现循环队列需要此变量，链表结构不需要</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> front<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//队首指针</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> rear<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//队尾指针</span>    <span class="token keyword">public</span> <span class="token function">QueueArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>        Length<span class="token operator">=</span>length<span class="token punctuation">;</span>        head<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>Length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//队首队尾都指向0号位置</span>        front<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        rear<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">Length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span><span class="token keyword">this</span><span class="token punctuation">.</span>Length<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> front<span class="token operator">==</span>rear<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Length<span class="token operator">==</span><span class="token keyword">this</span><span class="token punctuation">.</span>front<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//循环标志</span>        <span class="token keyword">boolean</span> isMatch<span class="token operator">=</span><span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"队列为空！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>head<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>head<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>node<span class="token punctuation">)</span><span class="token punctuation">{</span>                isMatch<span class="token operator">=</span><span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isMatch<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"该元素不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Node node<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"队列已满！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>rear<span class="token punctuation">]</span><span class="token operator">=</span>node<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>rear<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>rear<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Length<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Node <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"当前队列为空！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Node temp<span class="token operator">=</span>head<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>front<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>front<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>front<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span>Length<span class="token punctuation">;</span>        <span class="token keyword">return</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
