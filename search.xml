<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git详细步骤</title>
      <link href="/2019/12/20/git%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/"/>
      <url>/2019/12/20/git%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/</url>
      
        <content type="html"><![CDATA[<p><strong>基本用法</strong></p><p><img src="https://img-blog.csdnimg.cn/20191014104801597.png" alt=""></p><p>上面的四条命令在工作目录、暂存目录(也叫做索引)和仓库之间复制文件</p><ol><li>git add <em>files</em> 把当前文件放入暂存区域</li><li>git commit 给暂存区域生成快照并提交</li><li>git reset – <em>files</em> 用来撤销最后一次git add <em>files</em>，你也可以用git reset 撤销所有暂存区域文件</li><li>git checkout – <em>files</em> 把文件从暂存区域复制到工作目录，用来丢弃本地修改</li></ol><p><strong>你可以用</strong> <strong>git reset -p,</strong> <strong>git checkout -p, or</strong> <strong>git add -p进入交互模式。</strong></p><p><strong>也可以跳过暂存区域直接从仓库取出文件或者直接提交代码。</strong></p><p><img src="https://img-blog.csdnimg.cn/20191014104801637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>命令详解</strong></p><p><strong>Diff</strong></p><p>查看两次提交之间的变动</p><p><img src="https://img-blog.csdnimg.cn/20191014104801640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>Commit</strong></p><p>提交时，git用暂存区域的文件创建一个新的提交，并把此时的节点设为父节点。然后把当前分支指向新的提交节点。下图中，当前分支是<em>master</em>。 在运行命令之前，<em>master</em>指向<em>ed489</em>，提交后，<em>master</em>指向新的节点<em>f0cec</em>并以<em>ed489</em>作为父节点。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>即便当前分支是某次提交的祖父节点，git会同样操作。下图中，在<em>master</em>分支的祖父节点<em>maint</em>分支进行一次提交，生成了<em>1800b</em>。 这样，<em>maint</em>分支就不再是<em>master</em>分支的祖父节点。此时合并(或者衍合) 是必须的。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>如果想更改一次提交，使用 git commit –amend。git会使用与当前提交相同的父节点进行一次新提交，旧的提交会被取消。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>另一个例子是分离HEAD提交,后文讲。</p><p><strong>Checkout</strong></p><p>checkout命令用于从历史提交（或者暂存区域）中拷贝文件到工作目录，也可用于切换分支。</p><p>当给定某个文件名（或者打开-p选项，或者文件名和-p选项同时打开）时，git会从指定的提交中拷贝文件到暂存区域和工作目录。比如，git checkout HEAD~ foo.c会将提交节点<em>HEAD~</em>(即当前提交节点的父节点)中的foo.c复制到工作目录并且加到暂存区域中。（如果命令中没有指定提交节点，则会从暂存区域中拷贝内容。）注意当前分支不会发生变化。</p><p><img src="https://img-blog.csdnimg.cn/2019101410480124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>当不指定文件名，而是给出一个（本地）分支时，那么<em>HEAD</em>标识会移动到那个分支（也就是说，我们”切换”到那个分支了），然后暂存区域和工作目录中的内容会和<em>HEAD</em>对应的提交节点一致。新提交节点（下图中的a47c3）中的所有文件都会被复制（到暂存区域和工作目录中）；只存在于老的提交节点（ed489）中的文件会被删除；不属于上述两者的文件会被忽略，不受影响。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801690.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>如果既没有指定文件名，也没有指定分支名，而是一个标签、远程分支、SHA-1值或者是像<em>master~3</em>类似的东西，就得到一个匿名分支，称作<em>detached HEAD</em>（被分离的<em>HEAD</em>标识）。这样可以很方便地在历史版本之间互相切换。比如说你想要编译1.6.6.1版本的git，你可以运行git checkout v1.6.6.1（这是一个标签，而非分支名），编译，安装，然后切换回另一个分支，比如说git checkout master。然而，当提交操作涉及到”分离的HEAD”时，其行为会略有不同，详情见在下面。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>HEAD标识处于分离状态时的提交操作</strong></p><p>当<em>HEAD</em>处于分离状态（不依附于任一分支）时，提交操作可以正常进行，但是不会更新任何已命名的分支。(你可以认为这是在更新一个匿名分支。)</p><p><img src="https://img-blog.csdnimg.cn/20191014104801714.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>一旦此后你切换到别的分支，比如说<em>master</em>，那么这个提交节点（可能）再也不会被引用到，然后就会被丢弃掉了。注意这个命令之后就不会有东西引用<em>2eecb</em>。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>但是，如果你想保存这个状态，可以用命令git checkout -b <em>name</em>来创建一个新的分支。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>Reset</strong></p><p>eset 命令把当前分支指向另一个位置，并且有选择的变动工作目录和索引。也用来在从历史仓库中复制文件到索引，而不动工作目录。</p><p>如果不给选项，那么当前分支指向到那个提交。如果用–hard选项，那么工作目录也更新，如果用–soft选项，那么都不变。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>如果没有给出提交点的版本号，那么默认用<em>HEAD</em>。这样，分支指向不变，但是索引会回滚到最后一次提交，如果用–hard选项，工作目录也同样。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>如果给了文件名(或者 -p选项), 那么工作效果和带文件名的 heckout 差不多，除了索引被更新。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>Merge</strong></p><p>merge 命令把不同分支合并起来。合并前，索引必须和当前提交相同。如果另一个分支是当前提交的祖父节点，那么合并命令将什么也不做。 另一种情况是如果当前提交是另一个分支的祖父节点，就导致<em>fast-forward</em>合并。指向只是简单的移动，并生成一个新的提交。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>否则就是一次真正的合并。默认把当前提交(<em>ed489</em> 如下所示)和另一个提交(<em>33104</em>)以及他们的共同祖父节点(<em>b325c</em>)进行一次<a href="http://en.wikipedia.org/wiki/Three-way_merge" target="_blank" rel="noopener">三方合并</a>。结果是先保存当前目录和索引，然后和父节点<em>33104</em>一起做一次新提交。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>Cherry Pick</strong></p><p>cherry-pick命令”复制”一个提交节点并在当前分支做一次完全一样的新提交。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p><strong>Rebase</strong></p><p>衍合是合并命令的另一种选择。合并把两个父分支合并进行一次提交，提交历史不是线性的。衍合在当前分支上重演另一个分支的历史，提交历史是线性的。 本质上，这是线性化的自动的 cherry-pick</p><p><img src="https://img-blog.csdnimg.cn/20191014104801874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>上面的命令都在<em>topic</em>分支中进行，而不是<em>master</em>分支，在<em>master</em>分支上重演，并且把分支指向新的节点。注意旧提交没有被引用，将被回收。</p><p>要限制回滚范围，使用–onto选项。下面的命令在<em>master</em>分支上重演当前分支从<em>169a6</em>以来的最近几个提交，即<em>2c33a</em>。</p><p><img src="https://img-blog.csdnimg.cn/20191014104801877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><p>同样有git rebase –interactive让你更方便的完成一些复杂操作，比如丢弃、重排、修改、合并提交。没有图片体现这些，细节看这里:<a href="http://www.kernel.org/pub/software/scm/git/docs/git-rebase.html#_interactive_mode" target="_blank" rel="noopener">git-rebase(1)</a></p><p><strong>技术说明</strong></p><p>文件内容并没有真正存储在索引(<em>.git/index</em>)或者提交对象中，而是以blob的形式分别存储在数据库中(<em>.git/objects</em>)，并用SHA-1值来校验。 索引文件用识别码列出相关的blob文件以及别的数据。对于提交来说，以树(<em>tree</em>)的形式存储，同样用对于的哈希值识别。树对应着工作目录中的文件夹，树中包含的 树或者blob对象对应着相应的子目录和文件。每次提交都存储下它的上一级树的识别码。</p><p>如果用detached HEAD提交，那么最后一次提交会被the reflog for HEAD引用。但是过一段时间就失效，最终被回收，与git commit –amend或者git rebase很像。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>百度文库文档下载</title>
      <link href="/2019/12/19/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E6%96%87%E6%A1%A3%E4%B8%8B%E8%BD%BD/"/>
      <url>/2019/12/19/%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93%E6%96%87%E6%A1%A3%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>之前用过一个百度文库在线下载文档的网站，非常好用，除了付费购买的不能下载之外其他的都可以下载，所以在这里安利一下。</p><p>网址：<a href="http://www.blpack.com/" target="_blank" rel="noopener">http://www.blpack.com/</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 资源分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 百度文库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器请求一个URL详细过程</title>
      <link href="/2019/12/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E4%B8%80%E4%B8%AAURL%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/12/12/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82%E4%B8%80%E4%B8%AAURL%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>基本每个人每天都会使用到浏览器进行上网，那么在我们输入一个网址后其背后运行的原理是什么样的？如何将一个玲琅满目的网页显示出来，其中经历了一个怎样的过程，总的来说，分为以下几个过程</p><ul><li>DNS解析</li><li>HTTP请求发送</li><li>服务器处理请求并返回结果</li><li>浏览器渲染页面</li><li>连接结束</li></ul><h1 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h1><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>DNS解析就是寻找要访问的资源的IP地址，在计算机网络中是根据IP地址对每台主机进行定位的，相当于唯一的<strong>标识</strong>。比如小明是一名大学生，有一天他想要上淘宝买一个耳机，在浏览器地址栏输入后进行访问时会先在<a href="www.taobao.com"></a><strong>hosts</strong>文件中查看，没有的话再在<strong>本地DNS服务器</strong>(一般为所在地运营商机房)查询，本地DNS收到查询请求后会在缓存中查询，如果还没有的话本地DNS将向根域名服务器发送请求，根域名服务器收到请求后一看后缀是<strong>.com</strong>，好了，把.com顶级域名服务器的地址返回，你去问它吧。然后.com顶级域名服务器中将<strong>taobao.com权威域名服务器</strong>返回，权威域名服务器最终返回taobao.com对应的IP地址，下图比较详细的说明了DNS解析的过程（该图源自网络）。</p><p><img src="https://i.loli.net/2019/12/19/u6wMaQhndYpxg91.png" alt="DNS解析过程"></p><p>可使用<strong>tracert</strong>命令跟踪到URL中间的网络节点</p><pre><code>tracert www.baidu.com</code></pre><p><strong>备注：</strong>事实上可能我们大部分情况下在电脑设置里看到的本地DNS服务器地址都是192.168.XX.XX,这个大多是局域网下的路由器，而路由器也只是起到了转发的作用，将DNS请求转发到运营商机房。</p><h2 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h2><p>在做完DNS解析后浏览器也就得到了要请求的主机IP，接下来就是向该主机发送请求信息。虽然我们不用去关心具体请求是怎么发送过去的，但是在这里还是大概说一下。</p><p>在连接发送过程中，大概使用了以下网络协议</p><ul><li>TCP    与服务器建立TCP连接</li><li>IP            网络层协议，用于发送IP数据包</li><li>OPSF      路由协议，IP数据包在路由器间传递基于相应路由协议</li><li>ARP协议    用于将IP地址转换为MAC地址（物理地址唯一）</li><li>HTTP协议    应用层协议，用于发送HTTP报文请求</li></ul><p>以上过程作为不同计算机之间通信的必须协议，看来计算机底层帮我们做了太多的工作了^.^</p><p>另外，由于考虑到安全性请求，事实上我们大部分情况下访问网站都是发送的<strong>HTTPS</strong>请求</p><p><img src="https://onedrive.gimhoy.com/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBcGtNdG56TnhsVm9lZWFlWUhfUXZsbHdRbkE=.png" alt="HTTPS原理"></p><p>上图中HTTPS实现加密的过程不必详细了解，只需要知道HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，如果想要深入研究可以参考本文——<a href="https://juejin.im/post/5d53aa04f265da03934bd70c" target="_blank" rel="noopener">图解HTTPS基本原理</a></p><h2 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h2><p>服务器主机上的服务器软件（tomcat、nginx、werkzurk等）在收到请求后，会处理请求并返回HTTP响应报文</p><p>HTTP响应报文由三部分组成：状态行、响应头部、响应正文</p><h3 id="状态行"><a href="#状态行" class="headerlink" title="状态行"></a>状态行</h3><p>由三部分组成——协议版本，状态码，状态码描述，之间由空格分隔，在这里列举了不同数字开头的状态码</p><ul><li><p>1xx：指示信息–表示请求已接收，继续处理。</p></li><li><p>2xx：成功–表示请求已被成功接收、理解、接受。</p></li><li><p>3xx：重定向–要完成请求必须进行更进一步的操作。</p></li><li><p>4xx：客户端错误–请求有语法错误或请求无法实现。</p></li><li><p>5xx：服务器端错误–服务器未能实现合法的请求。</p><p>我们所常见的404错误就是由于客户端发生错误</p></li></ul><h3 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h3><p>下面是一些常见的响应头部</p><table><thead><tr><th align="left">响应头</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Server</td><td align="left">服务器应用程序软件的名称和版本</td></tr><tr><td align="left">Content-Type</td><td align="left">响应正文的类型（是图片还是二进制字符串）</td></tr><tr><td align="left">Content-Charset</td><td align="left">响应正文使用的编码</td></tr><tr><td align="left">Content-Encoding</td><td align="left">响应正文使用的数据压缩格式</td></tr><tr><td align="left">Content-Language</td><td align="left">响应正文使用的语言</td></tr></tbody></table><p>响应示例</p><p><img src="https://i.loli.net/2019/12/19/vukOdIlys8pbmre.png" alt="响应头"></p><h2 id="浏览器渲染页面"><a href="#浏览器渲染页面" class="headerlink" title="浏览器渲染页面"></a>浏览器渲染页面</h2><p>在服务器处理好请求请求并返回后，浏览器会将返回的网页源码渲染出来，浏览器渲染页面基于webkit内核，先上一张图</p><p><img src="https://i.loli.net/2019/12/19/fJPeqGlQwYFvWtR.png" alt="页面渲染过程图"></p><p>从这张图，我们可以看到浏览器会解析三个东西：</p><ul><li><p>一个是HTML/SVG/XHTML，事实上，Webkit有三个C++的类对应这三类文档。解析这三种文件会产生一个DOM Tree</p></li><li><p>CSS，解析CSS会产生CSS规则树</p></li><li><p>Javascript，脚本，主要是通过DOM API和CSSOM API来操作DOM Tree和CSS Rule Tree</p></li></ul><p>在解析完成后浏览器引擎会通过DOM Tree 和 CSS Rule Tree 来构造 Rendering Tree，最后通过调用操作系统Native GUI的API绘制。具体可以参考<a href="https://coolshell.cn/articles/9666.html" target="_blank" rel="noopener">浏览器的渲染原理简介</a></p><h2 id="连接结束"><a href="#连接结束" class="headerlink" title="连接结束"></a>连接结束</h2><p>在渲染完成后一次访问请求也就结束了。事实上，第一次加载网页往往比较慢，但后续加载该网页会快很多，这是因为DNS缓存和浏览器缓存等起的作用，将一些静态资源暂时缓存到本地以备下次访问使用，可以提高了页面的加载速率，用户的体验感更好。</p><h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul><li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a></li><li><a href="https://coolshell.cn/articles/9666.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9666.html</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
            <tag> HTTP </tag>
            
            <tag> 页面渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>细说ip</title>
      <link href="/2019/11/05/%E7%BB%86%E8%AF%B4ip/"/>
      <url>/2019/11/05/%E7%BB%86%E8%AF%B4ip/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在互联网中，每台计算机要实现通信的前提就是互相知道对方的地址，那么这个地址就是<strong>IP</strong>，通过IP地址我们可以很方便的在因特网上进行寻址。IP地址现在由因特网和数字分配机构ICANN(Internet Corporation for Assigned Names and Numbers)进行分配。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>按照长度分为</p><ul><li><p><strong>IPV4</strong>地址（4字节）</p></li><li><p><strong>IPV6</strong>地址（16字节）</p><p>按照用途分为</p></li><li><p>公有地址（公网ip）</p></li><li><p>私有地址（内网ip）</p></li></ul><p>另外，IP地址的编址方法一共经过了三个阶段。</p><ol><li><p>分类的IP地址，最基本的编址方法，下文将详细叙述。</p></li><li><p>子网的划分，对最基本编址方法的改进，其标准RFC 950在1985年通过。</p></li><li><p>构成超网，属于比较新的无分类编址方法，1993年提出后很快得到推广应用<br>在分类IP地址中，IP地址由两段构成，网络号与主机号</p><pre><code>   IP地址  =网络号+主机号</code></pre></li></ol><h2 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h2><blockquote><p><strong>网际协议版本4</strong>（英语：<strong>I</strong>nternet <strong>P</strong>rotocol <strong>v</strong>ersion <strong>4</strong>，缩写：<strong>IPv4</strong>，又称<strong>互联网通信协议第四版</strong>）是<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">网际协议</a>开发过程中的第四个修订版本，也是此协议第一个被广泛部署和使用的版本。</p><p>IPv4是一种<a href="https://zh.wikipedia.org/wiki/%E7%84%A1%E9%80%A3%E6%8E%A5%E5%BC%8F%E9%80%9A%E8%A8%8A" target="_blank" rel="noopener">无连接</a>的协议，操作在使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2" target="_blank" rel="noopener">分组交换</a>的链路层（如<a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91" target="_blank" rel="noopener">以太网</a>）上。此协议会尽最大努力交付数据包，意即它不保证任何数据包均能送达目的地，也不保证所有数据包均按照正确的顺序无重复地到达。这些方面是由上层的传输协议（如<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">传输控制协议</a>）处理的。</p></blockquote><p>上边的话显得太专业，可能有的小伙伴会听不懂，其实简而言之IP地址就是给因特网上的每一个主机或路由器的每个接口分配一个在全世界范围内唯一的32位的标识符（其实就差不多相当于我们的电话号码）,一个IP地址在整个因特网范围内都是唯一的。</p><h3 id="分类的IP地址"><a href="#分类的IP地址" class="headerlink" title="分类的IP地址"></a>分类的IP地址</h3><p>首先介绍一下A类、B类、C类网络地址，详见下图<br><img src="https://onedrive.gimhoy.com/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBcGtNdG56TnhsVm9kaXRnWGlUdDZPMmVqNVU=.png" alt=""></p><ul><li>如上图所示，A类地址中最高位为0，剩下的31位中高7位为网络标识符，主机标识位为24位，意味着每个网络可以容纳1600多万台的主机，A 类占整个地址空间的 50%。 然而，只有 126 个组织可以分配 A 类网络地址。 有趣的是，每个组织都可以为 16,000,000 台主机提供地址。 超大型组织会分配整个 A 类地址块。 时至今日，仍有公司和政府组织拥有 A 类地址。 例如，通用电气公司拥有 3.0.0.0/8，苹果电脑公司拥有 17.0.0.0/8，美国 邮政总局拥有 56.0.0.0/8。</li><li>B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码，剩下的两段号码为本地计算机的号码。如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是“10”。B类IP地址中网络的标识长度为14位，主机标识的长度为16位，B类网络地址适用于中等规模规模的网络，每个网络所能容纳的计算机数为6万多台。B 类占整个地址空间的 25%。 最多 16,384 个组织可以分配 B 类网络地址，每个网络可以支持 65,534 台主机。 只有那些特大型的公司/组织或政府部门有可能会使用到所有 65,000 个地址。 与 A 类网络类似，B 类地址空间浪费许多 IP 地址。</li><li>C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是“110”。C类IP地址中网络的标识长度为21位，主机标识的长度为8位，C类网络地址数量较多，适用于小规模的局域网络，每个网络最多只能包含254台计算机。   C 类占整个地址空间的 12.5%。 许多组织可以获得 C 类网络，但是限于它们能够连接的主机总数。 事实上，在许多情况下，C 类地址对于大多数中型企业来说通常太小。<br>看完了三类地址的简单介绍后可能会有点一头雾水，没关系，看完下边你可能更懵<br><img src="https://onedrive.gimhoy.com/1drv/aHR0cHM6Ly8xZHJ2Lm1zL3UvcyFBcGtNdG56TnhsVm9kd0JQTzZkVmVBcFc2TEk=.png" alt=""></li></ul><h4 id="单播、多播、广播"><a href="#单播、多播、广播" class="headerlink" title="单播、多播、广播"></a>单播、多播、广播</h4><p>除了上面三种类型的IP地址外，还有几种特殊类型的IP地址，TCP/IP协议规定，凡IP地址中的第一个字节以“1110”开始的地址都叫多点广播地址。在这里就要说一下单播、广播、多播地址的区别。</p><blockquote><ul><li><p>单播地址是IP网络中最常见的。包含单播目标地址的分组发送给特定主机，一个这样的例子是，IP地址为192.168.1.5（源地址）的主机向IP地址为192.168.1.200（目标地址）的服务器请求网页。要发送和接收单播分组，IP分组报头中必须有一个目标IP地址，而以太网帧报头中必须有相应的目标MAC地址。IP地址和MAC地址一起将数据传输到特定的目标主机。</p></li><li><p>广播分组的目标IP地址的主机部分全为1，这意味着本地网络（广播域）中的所有主机都将接收并查看该分组。诸如ARP和DHCP等很多网络协议都使用广播。</p><p>例如：</p><p>C类网络192.168.1.0的默认子网掩码为255.255.255.0（掩码的255个数对应网络的网络地址个数），其广播地址为192.168.1.255，其主机部分为十进制数255或二进制数11111111（全为1）；</p><p>B类网络172.16.0.0的默认子网掩码为255.255.0.0，其广播地址为172.16.255.255；</p><p>A类网络10.0.0.0的默认子网掩码为255.0.0.0，其广播地址为10.255.255.255。</p><p>在以太网帧中，必须包含与广播IP地址对应的广播MAC地址。在以太网中，广播MAC地址长48位，其十六进制表示为FF-FF-FF-FF-FF-FF（全1为广播mac，主机地址为全1即广播ip地址）</p></li><li><p>多播地址让源设备能够将分组发送给一组设备。属于多播组的设备将被分配一个多播组IP地址，多播地址范围为224.0.0.0～239.255.255.255。由于多播地址表示一组设备（有时被称为主机组），因此只能用作分组的目标地址，源地址总是为单播地址。</p></li></ul></blockquote><p>因此，任何第一个字节大于223小于240的IP地址是多点广播地址；IP地址中的每一个字节都为0的地址（“0.0.0.0”）对应于当前主机；IP地址中的每一个字节都为1的IP地址（“255．255．255．255”）是当前子网的广播地址；IP地址中凡是以“llll0”的地址都留着将来作为特殊用途使用；IP地址中不能以十进制“127”作为开头，127.0.0.1是回送地址，指本地机，一般用来测试使用。回送地址（127.x.x.x）是本机回送地址（Loopback Address）,即主机IP堆栈内部的IP地址，主要用于网络软件测试以及本地机进程间通信，无论什么程序，一旦使用回送地址发送数据，协议软件立即返回之，不进行任何网络传输。 属于保留测试地址,不能用，同时网络ID的第一个6位组也不能全置为“0”，全“0”表示本地网络。   D 类和 E 类用于组播和保留地址。</p><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>未完待续……</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ip </tag>
            
            <tag> 局域网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前向代理与反向代理</title>
      <link href="/2019/11/01/%E5%89%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2019/11/01/%E5%89%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>   代理顾名思义就是自己不去干一件事，让别人帮你去干。同样的，我们在网络上访问一些服务时也需要通过代理去完成，比如有天你想要看某某hub,但是你在China时看不到的，所以此时你便需要一个国外的代理服务器代理你去访问，然后将结果返回给你，然后你就可以嘿嘿嘿了。<br>   <img src="https://img-blog.csdnimg.cn/20190409162703561.gif" alt=""></p><p>   在这里便是代理的一种应用，其实代理按照代理的方式一般可分为前向代理与反向代理</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><h3 id="前向代理"><a href="#前向代理" class="headerlink" title="前向代理"></a>前向代理</h3>  我们所见到的大部分情况都是前向代理，A客户端表面上与B服务器进行通信，但是事实上中间可能还经过了B服务器的转发，此时B服务器就起的是代理的作用，代理服务器是面向客户端的。刚开始我们所举的例子就属于前向代理范畴，通常用于访问某些服务受限时，起到了代理转发的作用。</li><li><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3>  反向代理我们可能见的并不多，但是却起到至关重要的作用，例如著名的Nginx服务器通常就起的是反向代理的作用。当你准备网上购物时，在浏览器地址栏输入taobao.com，域名地址经过DNS服务器解析后便可访问到对应的网站，这只是一个宏观上的过程，事实上在此过程中浏览器拿到服务器ip地址后便向服务器发送http请求，此时接受请求的就是nginx服务器(也可能是其他服务器，例如Apache等)，而nginx接收到请求后自己并不能处理请求，需要将请求转发到对应的web应用层进行处理，在进行完逻辑处理后，web应用层把请求返回给nginx,说：‘nginx，你可以把结果返回到客户端了’，nginx便乖乖的将结果返回到客户端，这便是反向代理在其中所起到的作用，隐匿了真正的业务逻辑层，提高了应用层安全性。<h5 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h5><ul><li>对客户端隐藏服务器（集群）的IP地址</li><li>安全：作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等</li><li>为后端服务器（集群）统一提供加密和SSL加速（如SSL终端代理）</li><li>负载均衡，若服务器集群中有负荷较高者，反向代理通过URL重写，根据连线请求从负荷较低者获取与所需相同的资源或备援</li><li>对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务<br>对一些内容进行压缩，以节约带宽或为网络带宽不佳的网络提供服务</li><li>减速上传</li><li>为在私有网络下（如局域网）的服务器集群提供NAT穿透及外网发布服务</li><li>提供HTTP访问认证[2]</li><li>突破互联网封锁（不常用，因为反向代理与客户端之间的连线不一定是加密连线，非加密连线仍有遭内容审查进而遭封禁的风险；此外面对针对域名的关键字过滤、DNS缓存污染/投毒攻击乃至深度数据包检测也无能为力）<h5 id="常见反向代理软件"><a href="#常见反向代理软件" class="headerlink" title="常见反向代理软件"></a>常见反向代理软件</h5></li><li>Nginx、Tengine</li><li>Apache HTTP Server</li><li>Varnish cache</li><li>Squid Cache</li><li>Traffic Server</li><li>HAProxy</li><li>YXORP</li><li>Polipo</li><li>Privoxy</li><li>IIS<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><a href="https://zh.m.wikipedia.org/zh-hans/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">维基百科-反向代理</a></li></ul></li></ul><p>​    </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单TCP服务器构建</title>
      <link href="/2019/11/01/%E7%AE%80%E5%8D%95TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA/"/>
      <url>/2019/11/01/%E7%AE%80%E5%8D%95TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="一-基本概念"><a href="#一-基本概念" class="headerlink" title="一.基本概念"></a>一.基本概念</h2><ul><li><strong>Socket(套接字）</strong></li></ul><blockquote><p> socket是一种操作系统提供的进程间通信机制。[1] 在操作系统中，通常会为应用程序提供一组应用程序接口（API），称为套接字接口（英语：socket API）。应用程序可以通过套接字接口，来使用网络套接字，以进行数据交换。最早的套接字接口来自于4.2 BSD，因此现代常见的套接字接口大多源自Berkeley套接字（Berkeley sockets）标准。在套接字接口中，以IP地址及通信端口组成套接字地址（socket address）。远程的套接字地址，以及本地的套接字地址完成连线后，再加上使用的协议（protocol），这个五元组（five-element tuple），作为套接字对（socket pairs），之后就可以彼此交换数据。例如，在同一台计算机上，TCP协议与UDP协议可以同时使用相同的port而互不干扰。<br>  操作系统根据套接字地址，可以决定应该将数据送达特定的行程或线程。这就像是电话系统中，以电话号码加上分机号码，来决定通话对象一般。<br> 材料来源：维基百科 </p></blockquote><p> 套接字顾名思义就是像插座一样起到了套接的作用。我们知道当不同的两台计算机进行通信时，需要通过彼此的ip地址进行寻址通信，但是计算机上面运行的软件很多，比如在你开微信的时候还听着歌，那么不同的应用程序进行通信时是如何做到互不影响的呢？这就是端口的用途，或许你觉得你可能用不到这个玩意，当你在网上输入任意一个网址时，浏览器都默认给网址的最后加上<strong>80(http协议通信默认端口)</strong>,程序便可以通过端口进行通信，传递信息。</p><ul><li><strong>TCP协议</strong><br> TCP为传输控制协议，我们所遇到的大部分通信都是基于TCP协议的可靠通信，TCP连接之所以可靠是因为TCP建立的是长连接，创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。<h2 id="二-实现原理"><a href="#二-实现原理" class="headerlink" title="二.实现原理"></a>二.实现原理</h2><ul><li><strong>创建socket</strong><br><img src="https://img-blog.csdnimg.cn/20190513171805553.png" alt=""><br>在这里我们直接导入socket模块，然后创建socket对象，socket类初始化时需要赋参数，因为我们这里创建的是TCP服务，所以就不应改动，如果创建Udp服务时则应该改为family=AF_INET,type=SOCK_DGRAM</li></ul></li></ul><p> <strong>socket类构建方法参数类型</strong><br><img src="https://img-blog.csdnimg.cn/20190513172445518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><ul><li><strong>客户端请求连接</strong><br>在这里为了简化，我直接使用socket测试工具进行连接，并发送数据‘hello’<br>accept()方法可以返回一个元组，为一个新的套接字与客户端ip地址与端口，之所以需要返回一个新的套接字是因为为了满足下一次的通信需要，如果使用一个套接字时那么当发送来别的请求时将无法继续监听，因为此时的socket正在使用，所以需要新建一个通信管道。<br><img src="https://img-blog.csdnimg.cn/20190513173044910.png" alt=""><h2 id="三-方法改进"><a href="#三-方法改进" class="headerlink" title="三.方法改进"></a>三.方法改进</h2>上面我们是从最底层建立TCP连接(即从建立最基本的socket开始),事实上在真正的开发中程序员很少去从最底层做，因为已经有了封装的比较好的类库，从而避免了重复造轮子，在这里我们将使用socketserver模块中的服务基类与请求处理基类实现该功能<br><img src="https://img-blog.csdnimg.cn/20190513174407801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""><br>这样我们便不用去关心底层建立socket的细节，而只关心业务逻辑的处理，使用TCPServer类有一个缺陷，就是只能为一个客户端服务，是单线程的，当我们想要创建多线程连接时可以使用<strong>ThreadingTCPServer</strong>类来满足。<br>另外，当我们想要去调整底部的socket时可以设置参数<strong>bind_and_activate=False</strong><br><img src="https://img-blog.csdnimg.cn/2019051317493676.png" alt=""></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈夫曼树及哈夫曼编码详解</title>
      <link href="/2019/10/25/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/10/25/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%8F%8A%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h3><blockquote><p>在讲哈夫曼树之前先来介绍一下哈夫曼编码的概念。在信息编码、数据压缩等方面，我们总是希望编码能够尽可能的简短一点，如此才能节省空间，提高传输效率。例如：如果采用等长编码的话编码’abcd’,则为00，01，10，11，此时占据8bit的空间，况且各个字符出现的频率还都为一次，如果出现多次则会效率很低；如果采用不等长编码的话则可以为：0，10，110，111，大家肯定会有一个问题：为什么要写成这种形式呢？如果我分别编码为0，1，00，01的话可以吗？那么假如编码串为”001011”的话计算机便不能进行唯一的解码了，因为此时可能的结果有’aababb’,’addb’,’cbdb’,因此如果没有分隔符标注的话便会产生歧义。所以此时引入了一个<strong>前缀编码</strong>的概念——<strong>同一字符集中任何一个字符的编码都不是另外一个字符编码的前缀（最左字串），这种编码称为前缀编码。</strong></p></blockquote><hr><p>在真正压缩的时候我们希望出现频率高的字符所占用较小的编码长度，如果之前你学过离散数学的话应该会听过<strong>最优二叉树</strong>的概念，即让权值小的元素靠近根结点，哈夫曼树便是这个原理。</p><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><blockquote><p>路径：从树中一个结点到另一个结点之间的分支序列构成两个结点间的路径。</p><p>路径长度：路径上分支的条数称为路径长度。</p><p>树的路径长度：从树根到每个结点的路径长度之和称为树的路径长度。</p><p>结点的权：给树中结点赋予一个数值，该数值称为结点的权。</p><p>带权路径长度：结点到树根间的路径长度与结点权的乘积，称为该结点的带权路径长度。</p><p>树的带权路径长度：树中所有叶子结点的带权路径长度之和，称为树的带权路径长度，通常记为WPL</p><p>​                                                          <img src="https://private.codecogs.com/gif.latex?WPL%3D%20%5Csum_%7Bk%3D1%7D%5E%7Bn%7DW_%7Bk%7D*L_%7Bk%7D" alt=""></p><p>注：n为叶子结点个数（所要编码的字符数）</p></blockquote><p>在这里，最优二叉树的写法不在赘述，具体可参考：<a href="https://jingyan.baidu.com/article/380abd0a717c061d90192ca2.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/380abd0a717c061d90192ca2.html</a></p><h2 id="哈夫曼树的建立与编译码"><a href="#哈夫曼树的建立与编译码" class="headerlink" title="哈夫曼树的建立与编译码"></a>哈夫曼树的建立与编译码</h2><h3 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h3><p>哈夫曼树中没有度为1的结点，故n个叶子的哈夫曼树，恰有n-1个度为2的结点，所以哈夫曼树共有2n-1个结点，可以存储在一个大小为2n-1的一维数组中。</p><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Weight</td><td>Parent</td><td>Lchild</td><td>Rchild</td></tr></tbody></table><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//结构声明</span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> point<span class="token punctuation">{</span>    <span class="token keyword">int</span> weight<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//权值</span>    <span class="token keyword">int</span> parent<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//父节点下标</span>    <span class="token keyword">char</span> data<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//编码字母</span>    <span class="token keyword">int</span> code<span class="token punctuation">;</span>           <span class="token keyword">int</span> lchild<span class="token punctuation">,</span>rchild<span class="token punctuation">;</span><span class="token punctuation">}</span>HuffmanNode<span class="token punctuation">;</span></code></pre><h3 id="建立哈夫曼树"><a href="#建立哈夫曼树" class="headerlink" title="建立哈夫曼树"></a>建立哈夫曼树</h3><p>​     1.在建立前我们需要对每个字符求其权值，在这里我们以字符出现的频度作为权值的衡量标准。</p><pre class=" language-cpp"><code class="language-cpp">HuffmanNode <span class="token operator">*</span><span class="token function">Compute_weight</span><span class="token punctuation">(</span>HuffmanNode <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//计算权值</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span>p<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> p<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt=""></p><p>   2.利用其权值大小创建哈夫曼树</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">Build_HuffmanTree</span><span class="token punctuation">(</span>HuffmanNode <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//建立哈夫曼树</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> s1<span class="token punctuation">,</span>s2<span class="token punctuation">,</span><span class="token operator">*</span>min<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span><span class="token number">2</span><span class="token operator">*</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        min<span class="token operator">=</span><span class="token function">SearchMinNumbers</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s1<span class="token operator">=</span><span class="token operator">*</span>min<span class="token punctuation">;</span>        s2<span class="token operator">=</span><span class="token operator">*</span><span class="token punctuation">(</span>min<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">=</span>p<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token operator">+</span>p<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">.</span>weight<span class="token punctuation">;</span>        p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token operator">=</span>s1<span class="token punctuation">;</span>        p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rchild<span class="token operator">=</span>s2<span class="token punctuation">;</span>        p<span class="token punctuation">[</span>s1<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span>i<span class="token punctuation">;</span>        p<span class="token punctuation">[</span>s2<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token operator">=</span>i<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt=""></p><p>3.哈夫曼树编码</p><p>​      此时我们规定左分支表示‘0’，右分支表示‘1’，用根结点到叶子结点路径上的分支符号组成的串，作为叶子节点字符的编码，这就是哈夫曼编码。</p><pre class=" language-cpp"><code class="language-cpp">HuffmanNode <span class="token function">ResolveHuffmanCode</span><span class="token punctuation">(</span>HuffmanNode <span class="token operator">*</span>p<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//打印字符编码</span><span class="token punctuation">{</span>    HuffmanNode ptemp<span class="token punctuation">;</span>    <span class="token keyword">char</span> <span class="token operator">*</span>code<span class="token punctuation">;</span>    <span class="token keyword">int</span> start<span class="token punctuation">,</span>pre<span class="token punctuation">;</span>    code<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">mallco</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>    code<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'\0'</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        start<span class="token operator">=</span>n<span class="token number">-1</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        ptemp<span class="token operator">=</span>i<span class="token punctuation">;</span>        pre<span class="token operator">=</span>p<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>p<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">.</span>lchild<span class="token operator">==</span>ptemp<span class="token punctuation">)</span>                code<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                code<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">;</span>            ptemp<span class="token operator">=</span>pre<span class="token punctuation">;</span>            pre<span class="token operator">=</span>p<span class="token punctuation">[</span>ptemp<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span>            start<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt=""></p><p>4.哈夫曼树译码</p><p>哈夫曼译码过程较为简单，可按照编码表采用朴素字符串比对的方法进行解码，但是建议采用KMP算符进行字符串匹配，效率较高</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈夫曼树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java构造器调用顺序</title>
      <link href="/2019/10/21/java%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F/"/>
      <url>/2019/10/21/java%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在看书的时候，看到了关于继承的知识，突然觉得之前的理解还是不够，就想着把学到的关于构造器的知识记录下来</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>相信大部分人都知道java里边的构造器在做一件什么样的事———创建实例对象时进行初始化，比如：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">boolean</span> is_man<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       Test test<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt=""></p><p>上边这段代码在做着一件简简单单的事情，在堆内存中申请一块内存，创建类的实体对象并为变量赋初值（数值型为0，布尔型为false）。很多人会认为执行构造器方法就是在创建方法，事实上在构造器方法执行前系统已经创建了对象，只不过该对象当前还不能被外界访问而已，构造器函数当前只是执行了成员变量的初始化功能。</p><h2 id="继承中的构造器"><a href="#继承中的构造器" class="headerlink" title="继承中的构造器"></a>继承中的构造器</h2><p>在这里有一个很典型的例子</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String msg<span class="token operator">=</span><span class="token string">"I'am animal"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Animal</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">" belongs to animal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String msg<span class="token operator">=</span><span class="token string">"I'am human"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Human</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Human</span><span class="token punctuation">(</span><span class="token keyword">int</span> history<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">"horse"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Human society has a long history about "</span><span class="token operator">+</span>history<span class="token operator">+</span><span class="token string">" years"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String msg<span class="token operator">=</span><span class="token string">"I'am a woman"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt=""></p><p>上边的程序生动的展现了类继承树中构造器方法的调用顺序，当创建一个子类对象时，系统会依次向上回溯，从继承树顶端的Object类的构造器开始执行，依次往下执行，当在子类中显式调用重载的父类构造器函数时，便不再执行默认的构造器，如果未显式调用时则执行默认的构造器函数，上面代码的执行结果如下：</p><pre><code>horse belongs to animalHuman society has a long history about 5000 yearsI'am a woman</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt=""></p><p>最后，重要的事情说三遍：</p><p><strong>创建子类对象时没有创建父类对象，只是执行了父类的构造器函数！</strong></p><p><strong>创建子类对象时没有创建父类对象，只是执行了父类的构造器函数！</strong></p><p><strong>创建子类对象时没有创建父类对象，只是执行了父类的构造器函数！</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造器 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
