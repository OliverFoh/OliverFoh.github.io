<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>细说ip</title>
      <link href="/2019/11/05/%E7%BB%86%E8%AF%B4ip/"/>
      <url>/2019/11/05/%E7%BB%86%E8%AF%B4ip/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在互联网中，每台计算机要实现通信的前提就是互相知道对方的地址，那么这个地址就是<strong>IP</strong></p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p>按照长度分为</p><ul><li><p><strong>IPV4</strong>地址（4字节）</p></li><li><p><strong>IPV6</strong>地址（16字节）</p><p>按照用途分为</p></li><li><p>公有地址（公网ip）</p></li><li><p>私有地址（内网ip）</p></li></ul><h2 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h2><blockquote><p><strong>网际协议版本4</strong>（英语：<strong>I</strong>nternet <strong>P</strong>rotocol <strong>v</strong>ersion <strong>4</strong>，缩写：<strong>IPv4</strong>，又称<strong>互联网通信协议第四版</strong>）是<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">网际协议</a>开发过程中的第四个修订版本，也是此协议第一个被广泛部署和使用的版本。</p><p>IPv4是一种<a href="https://zh.wikipedia.org/wiki/%E7%84%A1%E9%80%A3%E6%8E%A5%E5%BC%8F%E9%80%9A%E8%A8%8A" target="_blank" rel="noopener">无连接</a>的协议，操作在使用<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2" target="_blank" rel="noopener">分组交换</a>的链路层（如<a href="https://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91" target="_blank" rel="noopener">以太网</a>）上。此协议会尽最大努力交付数据包，意即它不保证任何数据包均能送达目的地，也不保证所有数据包均按照正确的顺序无重复地到达。这些方面是由上层的传输协议（如<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">传输控制协议</a>）处理的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ip </tag>
            
            <tag> 局域网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前向代理与反向代理</title>
      <link href="/2019/11/01/%E5%89%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
      <url>/2019/11/01/%E5%89%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>   代理顾名思义就是自己不去干一件事，让别人帮你去干。同样的，我们在网络上访问一些服务时也需要通过代理去完成，比如有天你想要看某某hub,但是你在China时看不到的，所以此时你便需要一个国外的代理服务器代理你去访问，然后将结果返回给你，然后你就可以嘿嘿嘿了。<br>   <img src="https://img-blog.csdnimg.cn/20190409162703561.gif" alt="在这里插入图片描述"></p><p>   在这里便是代理的一种应用，其实代理按照代理的方式一般可分为前向代理与反向代理</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li><h3 id="前向代理"><a href="#前向代理" class="headerlink" title="前向代理"></a>前向代理</h3>  我们所见到的大部分情况都是前向代理，A客户端表面上与B服务器进行通信，但是事实上中间可能还经过了B服务器的转发，此时B服务器就起的是代理的作用，代理服务器是面向客户端的。刚开始我们所举的例子就属于前向代理范畴，通常用于访问某些服务受限时，起到了代理转发的作用。</li><li><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3>  反向代理我们可能见的并不多，但是却起到至关重要的作用，例如著名的Nginx服务器通常就起的是反向代理的作用。当你准备网上购物时，在浏览器地址栏输入taobao.com，域名地址经过DNS服务器解析后便可访问到对应的网站，这只是一个宏观上的过程，事实上在此过程中浏览器拿到服务器ip地址后便向服务器发送http请求，此时接受请求的就是nginx服务器(也可能是其他服务器，例如Apache等)，而nginx接收到请求后自己并不能处理请求，需要将请求转发到对应的web应用层进行处理，在进行完逻辑处理后，web应用层把请求返回给nginx,说：‘nginx，你可以把结果返回到客户端了’，nginx便乖乖的将结果返回到客户端，这便是反向代理在其中所起到的作用，隐匿了真正的业务逻辑层，提高了应用层安全性。<h5 id="主要功能："><a href="#主要功能：" class="headerlink" title="主要功能："></a>主要功能：</h5><ul><li>对客户端隐藏服务器（集群）的IP地址</li><li>安全：作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等</li><li>为后端服务器（集群）统一提供加密和SSL加速（如SSL终端代理）</li><li>负载均衡，若服务器集群中有负荷较高者，反向代理通过URL重写，根据连线请求从负荷较低者获取与所需相同的资源或备援</li><li>对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务<br>对一些内容进行压缩，以节约带宽或为网络带宽不佳的网络提供服务</li><li>减速上传</li><li>为在私有网络下（如局域网）的服务器集群提供NAT穿透及外网发布服务</li><li>提供HTTP访问认证[2]</li><li>突破互联网封锁（不常用，因为反向代理与客户端之间的连线不一定是加密连线，非加密连线仍有遭内容审查进而遭封禁的风险；此外面对针对域名的关键字过滤、DNS缓存污染/投毒攻击乃至深度数据包检测也无能为力）<h5 id="常见反向代理软件"><a href="#常见反向代理软件" class="headerlink" title="常见反向代理软件"></a>常见反向代理软件</h5></li><li>Nginx、Tengine</li><li>Apache HTTP Server</li><li>Varnish cache</li><li>Squid Cache</li><li>Traffic Server</li><li>HAProxy</li><li>YXORP</li><li>Polipo</li><li>Privoxy</li><li>IIS<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><a href="https://zh.m.wikipedia.org/zh-hans/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" target="_blank" rel="noopener">维基百科-反向代理</a></li></ul></li></ul><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单TCP服务器构建</title>
      <link href="/2019/11/01/%E7%AE%80%E5%8D%95TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA/"/>
      <url>/2019/11/01/%E7%AE%80%E5%8D%95TCP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%84%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="一-基本概念"><a href="#一-基本概念" class="headerlink" title="一.基本概念"></a>一.基本概念</h2><ul><li><strong>Socket(套接字）</strong></li></ul><blockquote><p> socket是一种操作系统提供的进程间通信机制。[1] 在操作系统中，通常会为应用程序提供一组应用程序接口（API），称为套接字接口（英语：socket API）。应用程序可以通过套接字接口，来使用网络套接字，以进行数据交换。最早的套接字接口来自于4.2 BSD，因此现代常见的套接字接口大多源自Berkeley套接字（Berkeley sockets）标准。在套接字接口中，以IP地址及通信端口组成套接字地址（socket address）。远程的套接字地址，以及本地的套接字地址完成连线后，再加上使用的协议（protocol），这个五元组（five-element tuple），作为套接字对（socket pairs），之后就可以彼此交换数据。例如，在同一台计算机上，TCP协议与UDP协议可以同时使用相同的port而互不干扰。<br>  操作系统根据套接字地址，可以决定应该将数据送达特定的行程或线程。这就像是电话系统中，以电话号码加上分机号码，来决定通话对象一般。<br> 材料来源：维基百科 </p></blockquote><p> 套接字顾名思义就是像插座一样起到了套接的作用。我们知道当不同的两台计算机进行通信时，需要通过彼此的ip地址进行寻址通信，但是计算机上面运行的软件很多，比如在你开微信的时候还听着歌，那么不同的应用程序进行通信时是如何做到互不影响的呢？这就是端口的用途，或许你觉得你可能用不到这个玩意，当你在网上输入任意一个网址时，浏览器都默认给网址的最后加上<strong>80(http协议通信默认端口)</strong>,程序便可以通过端口进行通信，传递信息。</p><ul><li><strong>TCP协议</strong><br> TCP为传输控制协议，我们所遇到的大部分通信都是基于TCP协议的可靠通信，TCP连接之所以可靠是因为TCP建立的是长连接，创建TCP连接时，主动发起连接的叫客户端，被动响应连接的叫服务器。<h2 id="二-实现原理"><a href="#二-实现原理" class="headerlink" title="二.实现原理"></a>二.实现原理</h2><ul><li><strong>创建socket</strong><pre><code> ![](https://img-blog.csdnimg.cn/20190513171805553.png)</code></pre>在这里我们直接导入socket模块，然后创建socket对象，socket类初始化时需要赋参数，因为我们这里创建的是TCP服务，所以就不应改动，如果创建Udp服务时则应该改为family=AF_INET,type=SOCK_DGRAM</li></ul></li></ul><p> <strong>socket类构建方法参数类型</strong><br><img src="https://img-blog.csdnimg.cn/20190513172445518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""></p><ul><li><strong>客户端请求连接</strong><br>在这里为了简化，我直接使用socket测试工具进行连接，并发送数据‘hello’<br>accept()方法可以返回一个元组，为一个新的套接字与客户端ip地址与端口，之所以需要返回一个新的套接字是因为为了满足下一次的通信需要，如果使用一个套接字时那么当发送来别的请求时将无法继续监听，因为此时的socket正在使用，所以需要新建一个通信管道。<br><img src="https://img-blog.csdnimg.cn/20190513173044910.png" alt=""><h2 id="三-方法改进"><a href="#三-方法改进" class="headerlink" title="三.方法改进"></a>三.方法改进</h2>上面我们是从最底层建立TCP连接(即从建立最基本的socket开始),事实上在真正的开发中程序员很少去从最底层做，因为已经有了封装的比较好的类库，从而避免了重复造轮子，在这里我们将使用socketserver模块中的服务基类与请求处理基类实现该功能<br><img src="https://img-blog.csdnimg.cn/20190513174407801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZfSVRfYm95,size_16,color_FFFFFF,t_70" alt=""><br>这样我们便不用去关心底层建立socket的细节，而只关心业务逻辑的处理，使用TCPServer类有一个缺陷，就是只能为一个客户端服务，是单线程的，当我们想要创建多线程连接时可以使用<strong>ThreadingTCPServer</strong>类来满足。<br>另外，当我们想要去调整底部的socket时可以设置参数<strong>bind_and_activate=False</strong><br><img src="https://img-blog.csdnimg.cn/2019051317493676.png" alt=""></li></ul>]]></content>
      
      
      <categories>
          
          <category> 服务器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归模型分析</title>
      <link href="/2019/10/31/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90/"/>
      <url>/2019/10/31/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="线性回归模型分析"><a href="#线性回归模型分析" class="headerlink" title="线性回归模型分析"></a>线性回归模型分析</h1><h2 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a>基本概念：</h2><p>​    利用已知样本数据，产生拟合方程，从而对未知数据进行预测。依据描述自变量与因变量之间的因果关系的函数表达式是线性的还是非线性的，线性即为每个变量的指数幂不超过一次方，为直线形态。</p><h2 id="常见分类："><a href="#常见分类：" class="headerlink" title="常见分类："></a>常见分类：</h2><ul><li>一元线性回归</li><li>多元线性回归</li><li>岭回归</li></ul><h2 id="一元线性回归："><a href="#一元线性回归：" class="headerlink" title="一元线性回归："></a>一元线性回归：</h2><p><strong>基本概念</strong>：回归问题中只涉及到两个变量，主要任务为从两个相关变量中的一个去估计另外一个变量。</p><p><strong>常见形式</strong>：<strong>Y=βx+α+ε</strong></p><p>​    其中α为截距项，β为斜率，ε为误差项</p><p><img src="https://i.loli.net/2019/04/29/5cc6637251fa4.png" alt=""></p><p><strong>求解目标：</strong></p><p>在确定参数时由于点是离散的，所以不可能确保每个点都落在直线上，只能确定一个最佳拟合的直线，因此可以通过误差的平方和来衡量。</p><p><img src="https://i.loli.net/2019/04/29/5cc667e2e79a8.png" alt=""></p><p><strong>损失函数</strong></p><p><img src="https://i.loli.net/2019/05/05/5cceec9caca54.png" alt=""></p><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><p><strong>主要区别：</strong>多变量情况</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java构造器调用顺序</title>
      <link href="/2019/10/21/java%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F/"/>
      <url>/2019/10/21/java%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天在看书的时候，看到了关于继承的知识，突然觉得之前的理解还是不够，就想着把学到的关于构造器的知识记录下来</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>相信大部分人都知道java里边的构造器在做一件什么样的事———创建实例对象时进行初始化，比如</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">boolean</span> is_man<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>       Test test<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt=""></p><p>上边这段代码在做着一件简简单单的事情，在堆内存中申请一块内存，创建类的实体对象并为变量赋初值（数值型为0，布尔型为false）。很多人会认为执行构造器方法就是在创建方法，事实上在构造器方法执行前系统已经创建了对象，只不过该对象当前还不能被外界访问而已，构造器函数当前只是执行了成员变量的初始化功能。</p><h2 id="继承中的构造器"><a href="#继承中的构造器" class="headerlink" title="继承中的构造器"></a>继承中的构造器</h2><p>在这里有一个很典型的例子</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String msg<span class="token operator">=</span><span class="token string">"I'am animal"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Animal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Animal</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token operator">+</span><span class="token string">" belongs to animal"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String msg<span class="token operator">=</span><span class="token string">"I'am human"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Human</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Human</span><span class="token punctuation">(</span><span class="token keyword">int</span> history<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token string">"horse"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Human society has a long history about "</span><span class="token operator">+</span>history<span class="token operator">+</span><span class="token string">" years"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Woman</span> <span class="token keyword">extends</span> <span class="token class-name">Human</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String msg<span class="token operator">=</span><span class="token string">"I'am a woman"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Woman</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt=""></p><p>上边的程序生动的展现了类继承树中构造器方法的调用顺序，当创建一个子类对象时，系统会依次向上回溯，从继承树顶端的Object类的构造器开始执行，依次往下执行，当在子类中显式调用重载的父类构造器函数时，便不再执行默认的构造器，如果未显式调用时则执行默认的构造器函数，上面代码的执行结果如下：</p><pre><code>horse belongs to animalHuman society has a long history about 5000 yearsI&#39;am a woman</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt=""></p><p>最后，重要的事情说三遍：</p><p><strong>创建子类对象时没有创建父类对象，只是执行了父类的构造器函数！</strong></p><p><strong>创建子类对象时没有创建父类对象，只是执行了父类的构造器函数！</strong></p><p><strong>创建子类对象时没有创建父类对象，只是执行了父类的构造器函数！</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造器 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
